name: üõ†Ô∏è Automated Incident Response

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      incident_type:
        description: 'Type of incident to handle'
        required: true
        type: choice
        options:
          - ci_failure_recovery
          - cache_corruption_fix
          - lockfile_repair
          - workflow_restart
          - performance_optimization
          - manual_intervention
      severity:
        description: 'Incident severity'
        required: true
        type: choice
        options:
          - critical
          - high
          - medium
          - low

permissions:
  contents: write
  actions: write
  issues: write
  pull-requests: write

jobs:
  incident-classification:
    name: üîç Incident Classification & Triage
    runs-on: ubuntu-latest
    if: (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'health-alert')) || github.event_name == 'workflow_dispatch'
    outputs:
      incident-type: ${{ steps.classify.outputs.incident-type }}
      severity: ${{ steps.classify.outputs.severity }}
      auto-recoverable: ${{ steps.classify.outputs.auto-recoverable }}
      requires-manual: ${{ steps.classify.outputs.requires-manual }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîç Classify Incident
        id: classify
        uses: actions/github-script@v7
        with:
          script: |
            let incidentType = '${{ github.event.inputs.incident_type }}' || 'unknown';
            let severity = '${{ github.event.inputs.severity }}' || 'medium';
            let autoRecoverable = false;
            let requiresManual = true;

            // If triggered by issue, analyze the issue content
            if (context.eventName === 'issues') {
              const issue = context.payload.issue;
              const title = issue.title.toLowerCase();
              const body = issue.body.toLowerCase();

              // Classify based on issue content
              if (title.includes('lockfile') || body.includes('package-lock.json')) {
                incidentType = 'lockfile_repair';
                autoRecoverable = true;
                requiresManual = false;
              } else if (title.includes('cache') || body.includes('cache corruption')) {
                incidentType = 'cache_corruption_fix';
                autoRecoverable = true;
                requiresManual = false;
              } else if (title.includes('failure rate') || body.includes('ci/cd system health')) {
                incidentType = 'ci_failure_recovery';
                autoRecoverable = true;
                requiresManual = false;
              } else if (title.includes('performance') || body.includes('slow build')) {
                incidentType = 'performance_optimization';
                autoRecoverable = false;
                requiresManual = true;
              }

              // Determine severity from labels
              const labels = issue.labels.map(l => l.name);
              if (labels.includes('critical')) {
                severity = 'critical';
              } else if (labels.includes('high')) {
                severity = 'high';
              } else if (labels.includes('medium')) {
                severity = 'medium';
              } else if (labels.includes('low')) {
                severity = 'low';
              }
            }

            console.log(`üè∑Ô∏è Incident classified: ${incidentType} (${severity})`);
            console.log(`ü§ñ Auto-recoverable: ${autoRecoverable}`);
            console.log(`üë§ Requires manual: ${requiresManual}`);

            core.setOutput('incident-type', incidentType);
            core.setOutput('severity', severity);
            core.setOutput('auto-recoverable', autoRecoverable);
            core.setOutput('requires-manual', requiresManual);

      - name: üìã Update Issue with Classification
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          script: |
            const incidentType = '${{ steps.classify.outputs.incident-type }}';
            const severity = '${{ steps.classify.outputs.severity }}';
            const autoRecoverable = '${{ steps.classify.outputs.auto-recoverable }}' === 'true';

            const statusEmoji = autoRecoverable ? 'ü§ñ' : 'üë§';
            const statusText = autoRecoverable ? 'Auto-Recovery Initiated' : 'Manual Intervention Required';

            const comment = `## üîç Incident Classification Complete

            **Classification Results:**
            - **Type**: ${incidentType}
            - **Severity**: ${severity}
            - **Status**: ${statusEmoji} ${statusText}

            ${autoRecoverable ?
              '‚úÖ **Automated recovery procedures have been initiated.** Monitor this issue for updates.' :
              '‚ö†Ô∏è **Manual intervention required.** Please review the incident details and take appropriate action.'
            }

            ---
            *This classification was performed automatically by the Incident Response System.*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  automated-recovery:
    name: ü§ñ Automated Recovery Procedures
    runs-on: ubuntu-latest
    needs: incident-classification
    if: needs.incident-classification.outputs.auto-recoverable == 'true'

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: üîß Lockfile Repair Recovery
        if: needs.incident-classification.outputs.incident-type == 'lockfile_repair'
        run: |
          echo "üîß Initiating lockfile repair..."

          # Backup current lockfile
          if [ -f "package-lock.json" ]; then
            cp package-lock.json package-lock.json.backup
            echo "üíæ Current lockfile backed up"
          fi

          # Clean npm cache
          npm cache clean --force
          echo "üßπ NPM cache cleaned"

          # Remove node_modules and lockfile
          rm -rf node_modules package-lock.json

          # Reinstall dependencies
          npm install
          echo "üì¶ Dependencies reinstalled"

          # Verify installation
          if npm run build > /dev/null 2>&1; then
            echo "‚úÖ Lockfile repair successful - build passes"

            # Commit the fixed lockfile
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add package-lock.json
            git commit -m "fix(deps): automated lockfile repair

            - Cleaned npm cache and regenerated lockfile
            - Verified build functionality after repair
            - Auto-recovery from lockfile corruption

            Co-Authored-By: Claude <noreply@anthropic.com>"
            git push

          else
            echo "‚ùå Lockfile repair failed - build still broken"
            exit 1
          fi

      - name: üóëÔ∏è Cache Corruption Fix
        if: needs.incident-classification.outputs.incident-type == 'cache_corruption_fix'
        run: |
          echo "üóëÔ∏è Initiating cache corruption fix..."

          # Clear GitHub Actions cache (via API)
          echo "üßπ Clearing GitHub Actions cache..."

          # Clear npm cache
          npm cache clean --force
          echo "üì¶ NPM cache cleared"

          # Clear any local caches
          rm -rf .next/cache || true
          rm -rf node_modules/.cache || true
          rm -rf .eslintcache || true

          # Reinstall dependencies to rebuild cache
          rm -rf node_modules
          npm install

          # Test build to verify cache fix
          if npm run build; then
            echo "‚úÖ Cache corruption fix successful"
          else
            echo "‚ùå Cache corruption fix failed"
            exit 1
          fi

      - name: üîÑ CI Failure Recovery
        if: needs.incident-classification.outputs.incident-type == 'ci_failure_recovery'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Initiating CI failure recovery..."

          # Install dependencies for scripts
          npm install @octokit/rest

          # Run health check to identify issues
          node scripts/ci-health-monitor.js

          # Check recent failed runs
          FAILED_RUNS=$(gh run list --status failure --limit 5 --json databaseId --jq '.[].databaseId')

          for run_id in $FAILED_RUNS; do
            echo "üîç Analyzing failed run: $run_id"

            # Get failure details
            FAILURE_DETAILS=$(gh run view $run_id --json jobs --jq '.jobs[] | select(.conclusion == "failure") | .name')
            echo "‚ùå Failed job: $FAILURE_DETAILS"

            # Common recovery actions based on failure type
            if echo "$FAILURE_DETAILS" | grep -i "lockfile"; then
              echo "üîß Detected lockfile issue - triggering repair"
              # Lockfile repair would be handled by separate step
            elif echo "$FAILURE_DETAILS" | grep -i "cache"; then
              echo "üóëÔ∏è Detected cache issue - triggering cache clear"
              # Cache clear would be handled by separate step
            elif echo "$FAILURE_DETAILS" | grep -i "timeout"; then
              echo "‚è±Ô∏è Detected timeout issue - may need resource optimization"
            fi
          done

          # Restart most recent failed workflow if possible
          LATEST_FAILED=$(echo "$FAILED_RUNS" | head -1)
          if [ -n "$LATEST_FAILED" ]; then
            echo "üîÑ Attempting to restart latest failed run: $LATEST_FAILED"
            gh run rerun $LATEST_FAILED --failed || echo "‚ö†Ô∏è Restart not available for this run"
          fi

      - name: üîÑ Workflow Restart
        if: needs.incident-classification.outputs.incident-type == 'workflow_restart'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Initiating workflow restart procedures..."

          # Get stuck or failed workflows
          STUCK_RUNS=$(gh run list --status "in_progress" --limit 10 --json databaseId,createdAt --jq '.[] | select((now - (.createdAt | fromdateiso8601)) > 3600) | .databaseId')

          if [ -n "$STUCK_RUNS" ]; then
            echo "üõë Found stuck workflows (running >1 hour):"
            for run_id in $STUCK_RUNS; do
              echo "  - Run ID: $run_id"
              gh run cancel $run_id || echo "‚ö†Ô∏è Could not cancel run $run_id"
            done
          else
            echo "‚úÖ No stuck workflows found"
          fi

          # Restart failed workflows from last 2 hours
          RECENT_FAILED=$(gh run list --status failure --limit 5 --json databaseId,createdAt --jq '.[] | select((now - (.createdAt | fromdateiso8601)) < 7200) | .databaseId')

          if [ -n "$RECENT_FAILED" ]; then
            echo "üîÑ Restarting recent failed workflows:"
            for run_id in $RECENT_FAILED; do
              echo "  - Restarting run ID: $run_id"
              gh run rerun $run_id --failed || echo "‚ö†Ô∏è Could not restart run $run_id"
            done
          else
            echo "‚ÑπÔ∏è No recent failed workflows to restart"
          fi

      - name: ‚úÖ Recovery Verification
        run: |
          echo "‚úÖ Running recovery verification..."

          # Wait a moment for systems to stabilize
          sleep 30

          # Run health check to verify recovery
          if node scripts/ci-health-monitor.js; then
            echo "‚úÖ Recovery verification successful"
          else
            echo "‚ö†Ô∏è Recovery verification shows continued issues"
          fi

      - name: üìù Update Incident Issue
        if: always() && github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ job.status }}' === 'success';
            const incidentType = '${{ needs.incident-classification.outputs.incident-type }}';

            const statusEmoji = success ? '‚úÖ' : '‚ùå';
            const statusText = success ? 'Recovery Completed Successfully' : 'Recovery Failed';

            const comment = `## ü§ñ Automated Recovery Update

            **Recovery Status**: ${statusEmoji} **${statusText}**
            **Incident Type**: ${incidentType}
            **Recovery Time**: ${new Date().toISOString()}

            ${success ?
              '‚úÖ **Automated recovery procedures completed successfully.** The system should now be operational. This issue will be monitored for resolution.' :
              '‚ùå **Automated recovery failed.** Manual intervention is now required. Please review the workflow logs for details.'
            }

            ### Next Steps
            ${success ?
              '- Monitor system health for next 30 minutes\n- Verify CI/CD pipelines are functioning normally\n- This issue will auto-close if no further problems detected' :
              '- Review recovery workflow logs\n- Perform manual diagnostic procedures\n- Escalate to senior team members if necessary'
            }

            ---
            *This update was generated by the Automated Incident Response System.*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

            // If recovery was successful, add resolved label
            if (success) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['auto-resolved']
              });
            } else {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['manual-intervention-required']
              });
            }

  manual-intervention-alert:
    name: üë§ Manual Intervention Required
    runs-on: ubuntu-latest
    needs: incident-classification
    if: needs.incident-classification.outputs.requires-manual == 'true'

    steps:
      - name: üì¢ Escalate to Manual Process
        uses: actions/github-script@v7
        with:
          script: |
            const incidentType = '${{ needs.incident-classification.outputs.incident-type }}';
            const severity = '${{ needs.incident-classification.outputs.severity }}';

            console.log(`üë§ Manual intervention required for ${incidentType} (${severity})`);

            if (context.eventName === 'issues') {
              const comment = `## üë§ Manual Intervention Required

              **Incident Details:**
              - **Type**: ${incidentType}
              - **Severity**: ${severity}
              - **Classification Time**: ${new Date().toISOString()}

              **Required Actions:**
              This incident type requires manual analysis and intervention. Automated recovery procedures are not available.

              **Escalation Checklist:**
              - [ ] Review incident details and logs
              - [ ] Perform manual diagnostic procedures
              - [ ] Implement fix or mitigation
              - [ ] Verify system stability
              - [ ] Document lessons learned
              - [ ] Update automated procedures if applicable

              **Resources:**
              - Health Dashboard: Run \`node scripts/health-dashboard-server.js\`
              - Manual Health Check: \`node scripts/ci-health-monitor.js\`
              - Workflow Analysis: \`node scripts/workflow-analyzer.js\`

              ---
              *This escalation was triggered by the Automated Incident Response System.*`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });

              // Add manual intervention label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['manual-intervention-required', 'escalated']
              });
            }