// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  output        = "../generated/prisma"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

/// User role within a family context
/// ADMIN: Full family management (billing, member management, settings)
/// MEMBER: Standard access (manage own data, view family data)
/// VIEWER: Read-only access (good for children learning about finances)
enum UserRole {
  ADMIN
  MEMBER
  VIEWER

  @@map("user_role")
}

/// User account status
/// ACTIVE: Normal operation
/// INACTIVE: Temporarily disabled (e.g., parent disables child account)
/// SUSPENDED: System-level suspension (security/policy violation)
enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED

  @@map("user_status")
}

/// Financial account type
/// Maps to standard banking account categories
enum AccountType {
  CHECKING
  SAVINGS
  CREDIT_CARD
  INVESTMENT
  LOAN
  MORTGAGE
  OTHER

  @@map("account_type")
}

/// Account operational status
/// ACTIVE: Normal operation, syncing enabled
/// INACTIVE: User-disabled, no syncing
/// CLOSED: Permanently closed account
/// ERROR: Sync/connection error, needs attention
enum AccountStatus {
  ACTIVE
  INACTIVE
  CLOSED
  ERROR

  @@map("account_status")
}

/// Account data source
/// SALTEDGE: Synced via SaltEdge API
/// TINK: Synced via Tink API
/// YAPILY: Synced via Yapily API
/// PLAID: Synced via Plaid API (legacy)
/// MANUAL: User-entered data
enum AccountSource {
  SALTEDGE
  TINK
  YAPILY
  PLAID
  MANUAL

  @@map("account_source")
}

/// Banking provider selection
/// Used to route requests to correct API provider
enum BankingProvider {
  MANUAL       // User manually entered
  SALTEDGE     // GoCardless SaltEdge (MVP)
  TINK         // Tink by Visa (Phase 2)
  YAPILY       // Yapily (Phase 3)
  TRUELAYER    // TrueLayer (Phase 3)

  @@map("banking_provider")
}

/// Banking connection status
/// Tracks OAuth flow and account linking state
enum BankingConnectionStatus {
  PENDING      // Link initiated, user not yet authorized
  IN_PROGRESS  // User in OAuth flow
  AUTHORIZED   // Successfully authorized
  REVOKED      // User disconnected
  EXPIRED      // Link expired (90 days for SaltEdge)
  FAILED       // Authorization failed

  @@map("banking_connection_status")
}

/// Banking sync status
/// Tracks account synchronization state
enum BankingSyncStatus {
  PENDING      // Awaiting first sync
  SYNCING      // Currently syncing
  SYNCED       // Successfully synced
  ERROR        // Sync failed
  DISCONNECTED // User disconnected, no syncing

  @@map("banking_sync_status")
}

/// Transaction type
/// DEBIT: Money out (expenses, withdrawals)
/// CREDIT: Money in (income, deposits)
enum TransactionType {
  DEBIT
  CREDIT

  @@map("transaction_type")
}

/// Flow type for semantic transaction classification
/// EXPENSE: Regular spending (food, utilities, entertainment)
/// INCOME: Money received (salary, freelance, gifts)
/// TRANSFER: Internal movement between accounts (not true income/expense)
/// LIABILITY_PAYMENT: Payment towards debt (credit card, BNPL, loan)
/// REFUND: Money returned (partial or full reversal of prior transaction)
enum FlowType {
  EXPENSE
  INCOME
  TRANSFER
  LIABILITY_PAYMENT
  REFUND

  @@map("flow_type")
}

/// Transfer role for linked transfer transactions
/// SOURCE: The account sending money (debit side of transfer)
/// DESTINATION: The account receiving money (credit side of transfer)
enum TransferRole {
  SOURCE
  DESTINATION

  @@map("transfer_role")
}

/// Transaction processing status
/// PENDING: Not yet cleared/posted
/// POSTED: Cleared and finalized
/// CANCELLED: Transaction reversed/cancelled
enum TransactionStatus {
  PENDING
  POSTED
  CANCELLED

  @@map("transaction_status")
}

/// Transaction data source
/// PLAID: Auto-synced via Plaid API
/// MANUAL: User-entered transaction
/// IMPORT: Bulk imported (CSV, etc.)
enum TransactionSource {
  PLAID
  MANUAL
  IMPORT
  SALTEDGE

  @@map("transaction_source")
}

/// Category type classification
/// INCOME: Revenue categories (salary, freelance, etc.)
/// EXPENSE: Spending categories (food, transportation, etc.)
/// TRANSFER: Inter-account transfers
enum CategoryType {
  INCOME
  EXPENSE
  TRANSFER

  @@map("category_type")
}

/// Category operational status
/// ACTIVE: Normal operation, visible to users
/// INACTIVE: Hidden but preserved for history
/// ARCHIVED: Soft-deleted, not shown in dropdowns
enum CategoryStatus {
  ACTIVE
  INACTIVE
  ARCHIVED

  @@map("category_status")
}

/// Budget period type
/// MONTHLY: Standard monthly budget cycle
/// QUARTERLY: 3-month budget planning
/// YEARLY: Annual budget allocation
/// CUSTOM: User-defined date range
enum BudgetPeriod {
  MONTHLY
  QUARTERLY
  YEARLY
  CUSTOM

  @@map("budget_period")
}

/// Budget operational status
/// ACTIVE: Currently tracking expenses
/// COMPLETED: Period ended, archived for reporting
/// DRAFT: In planning, not yet active
enum BudgetStatus {
  ACTIVE
  COMPLETED
  DRAFT

  @@map("budget_status")
}

/// Achievement type classification
/// SAVINGS: Savings milestones (e.g., "Save $1000")
/// BUDGET: Budget adherence (e.g., "Stay under budget for 3 months")
/// CONSISTENCY: Regular activity (e.g., "Log transactions 30 days straight")
/// EDUCATION: Financial literacy (e.g., "Complete budgeting tutorial")
enum AchievementType {
  SAVINGS
  BUDGET
  CONSISTENCY
  EDUCATION

  @@map("achievement_type")
}

/// User achievement status
/// LOCKED: Not yet unlocked, shows requirements
/// IN_PROGRESS: Requirements being tracked, shows progress
/// UNLOCKED: Achievement earned, timestamp recorded
enum AchievementStatus {
  LOCKED
  IN_PROGRESS
  UNLOCKED

  @@map("achievement_status")
}

/// Liability type classification
/// CREDIT_CARD: Credit card balance (monthly cycle)
/// BNPL: Buy Now Pay Later (Klarna, PayPal Pay-in-3, Affirm, etc.)
/// LOAN: Personal/auto/other installment loans
/// MORTGAGE: Home mortgage (long-term)
/// OTHER: Other debt types
enum LiabilityType {
  CREDIT_CARD
  BNPL
  LOAN
  MORTGAGE
  OTHER

  @@map("liability_type")
}

/// Liability status
/// ACTIVE: Currently tracking payments
/// PAID_OFF: Fully paid, kept for history
/// CLOSED: Manually closed, no longer tracked
enum LiabilityStatus {
  ACTIVE
  PAID_OFF
  CLOSED

  @@map("liability_status")
}

/// Notification type classification
/// BUDGET_ALERT: Budget threshold exceeded
/// BILL_REMINDER: Upcoming bill due date
/// TRANSACTION_ALERT: Large or unusual transaction
/// SYNC_ERROR: Banking connection issue
/// ACHIEVEMENT: Achievement unlocked
/// SYSTEM: System announcements
enum NotificationType {
  BUDGET_ALERT
  BILL_REMINDER
  TRANSACTION_ALERT
  SYNC_ERROR
  ACHIEVEMENT
  SYSTEM

  @@map("notification_type")
}

/// Notification priority
/// LOW: Non-urgent, can be batched
/// MEDIUM: Normal priority, show when convenient
/// HIGH: Important, show immediately
/// URGENT: Critical, push immediately with sound
enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT

  @@map("notification_priority")
}

/// Notification status
/// PENDING: Not yet delivered
/// SENT: Delivered to device/channel
/// READ: User has seen/acknowledged
/// DISMISSED: User dismissed without action
enum NotificationStatus {
  PENDING
  SENT
  READ
  DISMISSED

  @@map("notification_status")
}

/// Recurrence frequency for scheduled transactions
/// DAILY: Every day
/// WEEKLY: Every week
/// BIWEEKLY: Every two weeks
/// MONTHLY: Every month
/// QUARTERLY: Every three months
/// YEARLY: Every year
enum RecurrenceFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  YEARLY

  @@map("recurrence_frequency")
}

/// Scheduled transaction status
/// ACTIVE: Will generate transactions on schedule
/// PAUSED: Temporarily suspended
/// COMPLETED: All occurrences generated
/// CANCELLED: Permanently stopped
enum ScheduledTransactionStatus {
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED

  @@map("scheduled_transaction_status")
}

/// Audit event types for security and account activity tracking
/// Covers password management, authentication, and account lifecycle events
enum AuditEventType {
  PASSWORD_CHANGED
  PASSWORD_RESET_REQUESTED
  PASSWORD_RESET_COMPLETED
  LOGIN_SUCCESS
  LOGIN_FAILED
  LOGIN_LOCKED
  ACCOUNT_CREATED
  ACCOUNT_DELETED
  ACCOUNT_SUSPENDED
  ACCOUNT_REACTIVATED
  TWO_FACTOR_ENABLED
  TWO_FACTOR_DISABLED

  @@map("audit_event_type")
}

// ============================================================================
// MODELS
// ============================================================================

/// Family entity - Core organizational unit for MoneyWise
/// Represents a household/family group with shared financial management
model Family {
  id        String   @id @default(uuid()) @db.Uuid
  name      String   @db.VarChar(255)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  users                 User[]
  accounts              Account[]
  categories            Category[]
  budgets               Budget[]
  liabilities           Liability[]
  scheduledTransactions ScheduledTransaction[]

  @@map("families")
}

/// User entity - Individual user within a family
/// Migrated from TypeORM with family relationship added
model User {
  id              String     @id @default(uuid()) @db.Uuid
  email           String     @unique @db.VarChar(255)
  firstName       String     @map("first_name") @db.VarChar(255)
  lastName        String     @map("last_name") @db.VarChar(255)
  passwordHash    String     @map("password_hash") @db.VarChar(255)
  role            UserRole   @default(MEMBER)
  status          UserStatus @default(ACTIVE)
  avatar          String?    @db.VarChar(255)
  timezone        String?    @db.VarChar(50)
  currency        String     @default("USD") @db.VarChar(3)
  preferences     Json?      @db.JsonB
  lastLoginAt     DateTime?  @map("last_login_at") @db.Timestamptz
  emailVerifiedAt DateTime?  @map("email_verified_at") @db.Timestamptz
  createdAt       DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime   @updatedAt @map("updated_at") @db.Timestamptz

  // Family relationship
  // ARCHITECTURAL DECISION: familyId is REQUIRED
  // Rationale: MoneyWise is "family-first" - every user must belong to a family
  // Solo users automatically get a single-member family on signup
  // This ensures consistent data model and simplifies authorization logic
  familyId String @map("family_id") @db.Uuid
  family   Family @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // Relations
  // ARCHITECTURAL DECISION: User → Account relationship maintained
  // Users own their personal accounts, but family also has shared accounts
  // This enables both individual and family-level financial management
  accounts           Account[]
  bankingCustomers   BankingCustomer[]
  bankingConnections BankingConnection[]
  userAchievements   UserAchievement[]
  passwordHistory    PasswordHistory[]
  auditLogs          AuditLog[]
  userPreferences    UserPreferences?

  // Indexes for query performance
  @@index([email], name: "idx_users_email")
  @@index([familyId], name: "idx_users_family_id")
  @@index([status, createdAt], name: "idx_users_status_created")
  @@index([familyId, role], name: "idx_users_family_role")
  @@map("users")
}

/// Account entity - Financial account (bank, credit card, investment, etc.)
/// ARCHITECTURAL DECISION: Dual ownership model
/// - Personal accounts: userId set, familyId null
/// - Family accounts: familyId set, userId null
/// - Application layer enforces exactly one is set (XOR constraint)
/// - Enables both individual and shared family financial management
model Account {
  id   String @id @default(uuid()) @db.Uuid
  name String @db.VarChar(255)

  // Account classification
  type   AccountType   @default(OTHER)
  status AccountStatus @default(ACTIVE)
  source AccountSource

  // Balance tracking
  // ARCHITECTURAL DECISION: Use Decimal for money fields
  // Rationale: Float/Double precision errors are unacceptable for financial data
  // Example: 0.1 + 0.2 = 0.30000000000000004 in binary floating point
  // Decimal stores exact values, critical for money calculations
  currentBalance   Decimal  @default(0) @db.Decimal(15, 2)
  availableBalance Decimal? @db.Decimal(15, 2)
  creditLimit      Decimal? @db.Decimal(15, 2)
  currency         String   @default("USD") @db.VarChar(3)

  // Institution details
  institutionName String? @db.VarChar(255)
  accountNumber   String? @db.VarChar(255)
  routingNumber   String? @db.VarChar(255)

  // Plaid integration fields
  // ARCHITECTURAL DECISION: Store plaidAccessToken at account level
  // Rationale: One access token per Plaid Item (institution connection)
  // Multiple accounts can share same plaidItemId (e.g., checking + savings)
  plaidAccountId   String? @map("plaid_account_id") @db.VarChar(255)
  plaidItemId      String? @map("plaid_item_id") @db.VarChar(255)
  plaidAccessToken String? @map("plaid_access_token") @db.Text

  // Plaid metadata stored as JSONB
  // ARCHITECTURAL DECISION: Use JSONB instead of separate columns
  // Rationale: Plaid metadata evolves, JSONB provides flexibility
  // Application layer handles schema validation via TypeScript types
  // Expected shape: { mask, subtype, officialName, persistentAccountId }
  plaidMetadata Json? @db.JsonB

  // Banking provider integration fields
  // ARCHITECTURAL DECISION: Support multiple providers (SaltEdge, Tink, Yapily, etc.)
  // Rationale: Enable provider switching without data loss
  bankingProvider       BankingProvider?    @map("banking_provider")
  saltEdgeAccountId     String?             @map("saltedge_account_id") @db.VarChar(255)
  saltEdgeConnectionId  String?             @map("saltedge_connection_id") @db.VarChar(255)
  tinkAccountId         String?             @map("tink_account_id") @db.VarChar(255)
  yalilyAccountId       String?             @map("yapily_account_id") @db.VarChar(255)

  // Sync tracking
  syncStatus            BankingSyncStatus   @default(PENDING) @map("sync_status")

  // Sync settings
  isActive    Boolean   @default(true) @map("is_active")
  syncEnabled Boolean   @default(true) @map("sync_enabled")
  lastSyncAt  DateTime? @map("last_sync_at") @db.Timestamptz
  syncError   String?   @map("sync_error") @db.VarChar(500)

  // Account preferences stored as JSONB
  // Expected shape: { autoSync, syncFrequency, notifications, budgetIncluded }
  settings Json? @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Dual ownership relations
  // ARCHITECTURAL DECISION: Both nullable, XOR enforced at application layer
  // Rationale: Prisma does not support native XOR constraints
  // Application must validate: (userId IS NULL) XOR (familyId IS NULL)
  // Consider adding DB check constraint in migration for data integrity
  userId String? @map("user_id") @db.Uuid
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  familyId String? @map("family_id") @db.Uuid
  family   Family? @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // Relations
  transactions   Transaction[]
  syncLogs       BankingSyncLog[]
  liabilities    Liability[]

  @@unique([plaidAccountId], name: "uq_accounts_plaid_account")
  @@unique([saltEdgeAccountId], name: "uq_accounts_saltedge_account")
  @@unique([tinkAccountId], name: "uq_accounts_tink_account")
  @@unique([yalilyAccountId], name: "uq_accounts_yapily_account")

  // Indexes for query performance
  // ARCHITECTURAL DECISION: Index strategy for common query patterns
  // 1. Ownership lookups: userId, familyId
  // 2. Account filtering: (userId/familyId, status) for "show active accounts"
  // 3. Plaid sync: plaidItemId for batch sync operations
  // 4. Banking provider sync: (bankingProvider, syncStatus) for batch syncing
  // 5. Unique provider IDs: Prevent duplicate connections
  @@index([userId], name: "idx_accounts_user_id")
  @@index([familyId], name: "idx_accounts_family_id")
  @@index([userId, status], name: "idx_accounts_user_status")
  @@index([familyId, status], name: "idx_accounts_family_status")
  @@index([plaidItemId], name: "idx_accounts_plaid_item")
  @@index([bankingProvider, syncStatus], name: "idx_accounts_provider_sync")
  @@map("accounts")
}

/// Transaction entity - Individual financial transaction
/// ARCHITECTURAL DECISION: Immutable transaction history
/// - Transactions should not be deleted, only marked as CANCELLED
/// - Historical data is critical for financial reporting and auditing
/// - Exception: CASCADE delete when parent Account is deleted (account closure)
model Transaction {
  id String @id @default(uuid()) @db.Uuid

  // Amount and classification
  // ARCHITECTURAL DECISION: Store amount as absolute value
  // Rationale: Type field (DEBIT/CREDIT) determines flow direction
  // Application layer computes displayAmount (negative for expenses)
  // Simplifies aggregation queries: SUM(amount) WHERE type = 'DEBIT'
  amount   Decimal           @db.Decimal(15, 2)
  type     TransactionType
  status   TransactionStatus @default(POSTED)
  source   TransactionSource
  currency String            @default("USD") @db.VarChar(3)

  // Flow type for semantic classification
  // ARCHITECTURAL DECISION: flowType is the user-facing classification
  // While type (DEBIT/CREDIT) is for accounting, flowType adds context:
  // - EXPENSE: Regular spending (auto-assigned for DEBIT + expense category)
  // - INCOME: Money received (auto-assigned for CREDIT + income category)
  // - TRANSFER: Internal movement (linked via transferGroupId)
  // - LIABILITY_PAYMENT: Debt payments (links to Liability model)
  // - REFUND: Money returned (maintains history vs editing original)
  flowType FlowType? @map("flow_type")

  // Transfer linking
  // ARCHITECTURAL DECISION: Use UUID to group transfer pairs
  // When user moves $100 from Checking to Savings:
  // - Transaction 1: Checking, DEBIT, transferGroupId=X, transferRole=SOURCE
  // - Transaction 2: Savings, CREDIT, transferGroupId=X, transferRole=DESTINATION
  // Query transfers: WHERE transferGroupId IS NOT NULL
  transferGroupId String?       @map("transfer_group_id") @db.Uuid
  transferRole    TransferRole? @map("transfer_role")

  // Date tracking
  // ARCHITECTURAL DECISION: date as DATE, authorizedDate as TIMESTAMPTZ
  // Rationale: date is for financial reporting (day-level granularity)
  // authorizedDate preserves exact transaction time for Plaid data
  date           DateTime  @db.Date
  authorizedDate DateTime? @map("authorized_date") @db.Timestamptz

  // Description fields
  description         String  @db.VarChar(500)
  merchantName        String? @map("merchant_name") @db.VarChar(255)
  originalDescription String? @map("original_description") @db.VarChar(255)

  // Additional metadata
  reference   String? @db.VarChar(255)
  checkNumber String? @map("check_number") @db.VarChar(255)
  notes       String? @db.Text

  // Transaction flags
  isPending       Boolean @default(false) @map("is_pending")
  isRecurring     Boolean @default(false) @map("is_recurring")
  isHidden        Boolean @default(false) @map("is_hidden")
  includeInBudget Boolean @default(true) @map("include_in_budget")

  // Plaid integration fields
  plaidTransactionId String? @map("plaid_transaction_id") @db.VarChar(255)
  plaidAccountId     String? @map("plaid_account_id") @db.VarChar(255)

  // SaltEdge integration fields
  saltEdgeTransactionId String? @map("saltedge_transaction_id") @db.VarChar(255)

  // Complex metadata stored as JSONB
  // ARCHITECTURAL DECISION: Use JSONB for nested/evolving structures
  // Rationale: Plaid API provides rich metadata that changes over time
  // JSONB allows flexible storage without schema migrations
  // Application layer handles validation and type safety
  // PostgreSQL JSONB supports GIN indexes for JSON queries if needed

  // Plaid-specific metadata
  // Expected shape: { categoryId, categoryConfidenceLevel, transactionCode,
  //                   transactionType, locationId, merchantEntityId,
  //                   paymentChannel, authorizedDateTime, personalFinanceCategory }
  plaidMetadata Json? @db.JsonB

  // Location data (for merchant transactions)
  // Expected shape: { address, city, region, postalCode, country, lat, lon, storeNumber }
  location Json? @db.JsonB

  // User-defined tags (array of strings)
  // Expected shape: ["groceries", "work-expense", "reimbursable"]
  tags Json? @db.JsonB

  // File attachments (receipts, invoices)
  // Expected shape: [{ id, filename, mimetype, size, url }]
  attachments Json? @db.JsonB

  // Split transaction details
  // ARCHITECTURAL DECISION: Store split info in JSONB, not separate table
  // Rationale: Splits are uncommon, adding join complexity for rare case
  // JSONB keeps data co-located for better query performance
  // Expected shape: { isParent, parentId, splits: [{ amount, categoryId, description }] }
  splitDetails Json? @map("split_details") @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  // ARCHITECTURAL DECISION: CASCADE delete when Account deleted
  // Rationale: Transactions cannot exist without parent account
  // When user closes account, transaction history goes with it
  // For data retention: Export transactions before account deletion
  accountId String  @map("account_id") @db.Uuid
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // ARCHITECTURAL DECISION: SET NULL when Category deleted
  // Rationale: Category is optional classification, not required parent
  // If user deletes category, transactions remain but lose categorization
  // Application can provide "uncategorized" filter for these transactions
  categoryId String?   @map("category_id") @db.Uuid
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  @@unique([plaidTransactionId], name: "uq_transactions_plaid_id")
  @@unique([saltEdgeTransactionId], name: "uq_transactions_saltedge_id")
  // Indexes for query performance
  // ARCHITECTURAL DECISION: Time-series and filtering indexes
  // Common query patterns:
  // 1. Account transaction history: (accountId, date) for pagination
  // 2. Category spending reports: (categoryId, date) for time-range aggregation
  // 3. Status filtering: (status, date) for pending transaction views
  // 4. Merchant analysis: (merchantName, date) for spending patterns
  // 5. Amount queries: (amount, date) for large transaction alerts
  // 6. Plaid deduplication: UNIQUE on plaidTransactionId (when not null)
  @@index([accountId, date], name: "idx_transactions_account_date")
  @@index([categoryId, date], name: "idx_transactions_category_date")
  @@index([status, date], name: "idx_transactions_status_date")
  @@index([merchantName, date], name: "idx_transactions_merchant_date")
  @@index([amount, date], name: "idx_transactions_amount_date")
  // New indexes for Phase 0 schema additions
  @@index([flowType, date], name: "idx_transactions_flow_type_date")
  @@index([transferGroupId], name: "idx_transactions_transfer_group")
  @@map("transactions")
}

/// Category entity - Transaction classification system with hierarchical structure
/// ARCHITECTURAL DECISION: Self-referential tree structure
/// - Supports parent-child category hierarchy (e.g., "Food" → "Restaurants" → "Fast Food")
/// - parentId nullable: top-level categories have no parent
/// - Application layer must prevent circular references and enforce max depth
/// - TypeORM used "nested-set" tree structure; Prisma uses adjacency list (parent-child)
/// - Trade-off: Adjacency list simpler but requires recursive queries for full tree
model Category {
  id          String         @id @default(uuid()) @db.Uuid
  name        String         @db.VarChar(255)
  slug        String         @unique @db.VarChar(255)
  description String?        @db.Text
  type        CategoryType
  status      CategoryStatus @default(ACTIVE)

  // Visual customization
  color String? @db.VarChar(7) // Hex color code (#RRGGBB)
  icon  String? @db.VarChar(100) // Icon identifier (e.g., "utensils", "car")

  // System flags
  // ARCHITECTURAL DECISION: isDefault vs isSystem
  // isDefault: Pre-populated categories users can modify/delete
  // isSystem: Core categories protected from deletion (e.g., "Uncategorized")
  isDefault Boolean @default(false) @map("is_default")
  isSystem  Boolean @default(false) @map("is_system")

  // Ordering and hierarchy
  sortOrder Int @default(0) @map("sort_order")
  
  // Hierarchy depth managed by PostgreSQL trigger (trg_category_depth)
  // ARCHITECTURAL DECISION: Trigger-managed column to enforce max depth (3 levels)
  // Rationale: Database-level enforcement prevents invalid hierarchies even from direct SQL
  // Application can query by depth for UI rendering (e.g., show only top 2 levels)
  depth     Int @default(0) @db.Integer

  // Auto-categorization rules stored as JSONB
  // ARCHITECTURAL DECISION: Use JSONB for ML/rule-based categorization
  // Rationale: Categorization rules evolve with ML model updates
  // Expected shape: { keywords, merchantPatterns, amountRanges, autoAssign, confidence }
  rules Json? @db.JsonB

  // Budget and tax metadata stored as JSONB
  // Expected shape: { budgetEnabled, monthlyLimit, goalAmount, taxDeductible, businessExpense }
  metadata Json? @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Self-referential hierarchy
  // ARCHITECTURAL DECISION: Nullable parentId for top-level categories
  // Rationale: Enables flexible multi-level hierarchy
  // Application enforces max depth (e.g., 3 levels) to prevent deep nesting
  parentId String?    @map("parent_id") @db.Uuid
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Category[] @relation("CategoryHierarchy")

  // Family ownership
  // ARCHITECTURAL DECISION: Required familyId
  // Rationale: Categories are family-specific (custom categories per family)
  // System categories seeded for each family on creation
  familyId String @map("family_id") @db.Uuid
  family   Family @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // Relations
  transactions Transaction[]
  budgets      Budget[]

  // Indexes for query performance
  // ARCHITECTURAL DECISION: Index strategy for category queries
  // 1. Family + Type filtering: "Show all expense categories for this family"
  // 2. Family + Status filtering: "Show active categories"
  // 3. Parent lookups: "Get child categories of X"
  // 4. Slug uniqueness: Enforce per-family unique slugs
  @@unique([familyId, slug], name: "uq_categories_family_slug")
  @@index([familyId, type], name: "idx_categories_family_type")
  @@index([familyId, status], name: "idx_categories_family_status")
  @@index([parentId], name: "idx_categories_parent_id")
  @@index([type, status], name: "idx_categories_type_status")
  @@map("categories")
}

/// Budget entity - Financial spending limits and tracking
/// ARCHITECTURAL DECISION: Budget at Category level, not Account level
/// - Rationale: Users think "I want to spend $500/month on groceries" (category)
/// - Not: "I want my checking account limited to $X" (account-level limits are rare)
/// - Budgets track spending across all accounts within a category
model Budget {
  id     String       @id @default(uuid()) @db.Uuid
  name   String       @db.VarChar(255)
  amount Decimal      @db.Decimal(15, 2)
  period BudgetPeriod @default(MONTHLY)
  status BudgetStatus @default(ACTIVE)

  // Date range for budget period
  // ARCHITECTURAL DECISION: Store explicit start/end dates
  // Rationale: Supports both recurring (MONTHLY) and custom date ranges
  // For MONTHLY: startDate = first day of month, endDate = last day of month
  // For CUSTOM: User-specified date range
  // Application layer generates periods for recurring budgets
  startDate DateTime @map("start_date") @db.Date
  endDate   DateTime @map("end_date") @db.Date

  // Spending alerts
  // ARCHITECTURAL DECISION: Store alert thresholds as percentages
  // Rationale: "Alert me at 50%, 75%, 90% of budget" is common pattern
  // Application layer computes actual amounts and sends notifications
  alertThresholds Int[] @default([50, 75, 90]) @map("alert_thresholds") // Percentages

  // Budget settings stored as JSONB
  // Expected shape: { rolloverUnspent, includeHiddenTransactions, notifyOnOverspend }
  settings Json? @db.JsonB

  // Descriptive notes
  notes String? @db.Text

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Category relation
  // ARCHITECTURAL DECISION: Required categoryId
  // Rationale: Every budget must be tied to a category
  // Multi-category budgets can be handled via parent category budgets
  // Example: Budget for "Food" parent includes "Restaurants" + "Groceries" children
  categoryId String   @map("category_id") @db.Uuid
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  // Family ownership
  // ARCHITECTURAL DECISION: Required familyId
  // Rationale: Budgets are family-level planning tools
  // Individual users within family collaborate on shared budgets
  familyId String @map("family_id") @db.Uuid
  family   Family @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // Indexes for query performance
  // ARCHITECTURAL DECISION: Index strategy for budget queries
  // 1. Family + Status: "Show active budgets for this family"
  // 2. Family + Period: "Show all monthly budgets"
  // 3. Category lookup: "Get budget for category X"
  // 4. Date range queries: "Find budgets overlapping date range"
  @@index([familyId, status], name: "idx_budgets_family_status")
  @@index([familyId, period], name: "idx_budgets_family_period")
  @@index([categoryId], name: "idx_budgets_category_id")
  @@index([startDate, endDate], name: "idx_budgets_date_range")
  @@map("budgets")
}

/// Achievement entity - Gamification system for financial goals
/// ARCHITECTURAL DECISION: Two-table design (Achievement + UserAchievement)
/// - Achievement: Template definitions (title, description, requirements)
/// - UserAchievement: User progress tracking (status, progress, unlocked date)
/// - Rationale: Separates static definitions from dynamic user state
/// - Enables easy addition of new achievements without affecting user data
model Achievement {
  id          String          @id @default(uuid()) @db.Uuid
  title       String          @db.VarChar(255)
  description String          @db.Text
  type        AchievementType
  icon        String?         @db.VarChar(100) // Icon identifier (e.g., "trophy", "star")

  // Points and rewards
  // ARCHITECTURAL DECISION: Points system for gamification
  // Rationale: Points enable leaderboards, rewards, progression tiers
  // Future: Can be exchanged for features, badges, or family benefits
  points Int @default(0)

  // Achievement requirements stored as JSONB
  // ARCHITECTURAL DECISION: Flexible requirements structure
  // Rationale: Different achievement types have different requirements
  // Expected shape varies by type:
  //   SAVINGS: { targetAmount: 1000, timeframe: "monthly" }
  //   BUDGET: { categorySlugs: ["food"], underBudgetMonths: 3 }
  //   CONSISTENCY: { action: "log-transaction", consecutiveDays: 30 }
  //   EDUCATION: { tutorialId: "budgeting-101", completionPercentage: 100 }
  requirements Json @db.JsonB

  // Display and ordering
  sortOrder    Int     @default(0) @map("sort_order")
  isActive     Boolean @default(true) @map("is_active")
  isRepeatable Boolean @default(false) @map("is_repeatable") // Can be earned multiple times

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  userAchievements UserAchievement[]

  // Indexes for query performance
  @@index([type, isActive], name: "idx_achievements_type_active")
  @@index([sortOrder], name: "idx_achievements_sort")
  @@map("achievements")
}

/// UserAchievement entity - Tracks individual user progress on achievements
/// ARCHITECTURAL DECISION: Separate from Achievement for flexibility
/// - Enables per-user progress tracking without modifying Achievement template
/// - Supports repeatable achievements (multiple UserAchievement records per user)
/// - Allows historical tracking (when achievement was unlocked, progress snapshots)
model UserAchievement {
  id     String            @id @default(uuid()) @db.Uuid
  status AchievementStatus @default(LOCKED)

  // Progress tracking stored as JSONB
  // ARCHITECTURAL DECISION: Flexible progress structure matching requirements
  // Rationale: Progress shape varies by achievement type
  // Expected shape examples:
  //   SAVINGS: { currentAmount: 750, targetAmount: 1000, percentage: 75 }
  //   BUDGET: { monthsUnderBudget: 2, targetMonths: 3, categories: ["food"] }
  //   CONSISTENCY: { currentStreak: 15, targetDays: 30, lastLogDate: "2025-10-11" }
  //   EDUCATION: { sectionsCompleted: 8, totalSections: 10, percentage: 80 }
  progress Json? @db.JsonB

  // Unlock timestamp
  // ARCHITECTURAL DECISION: Separate unlockedAt field for analytics
  // Rationale: Enables "achievement unlocked on DATE" display and analytics
  // NULL when status != UNLOCKED
  unlockedAt DateTime? @map("unlocked_at") @db.Timestamptz

  // Notification flags
  // ARCHITECTURAL DECISION: Track notification state
  // Rationale: Prevent duplicate notifications, allow user control
  notifiedAt DateTime? @map("notified_at") @db.Timestamptz

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  // ARCHITECTURAL DECISION: Required achievementId and userId
  // Rationale: Every UserAchievement must link to an Achievement template and a User
  // CASCADE delete: If Achievement deleted, remove user progress (admin cleanup)
  // CASCADE delete: If User deleted, remove their achievement progress
  achievementId String      @map("achievement_id") @db.Uuid
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for query performance
  // ARCHITECTURAL DECISION: Index strategy for achievement queries
  // 1. User lookup: "Show all achievements for this user"
  // 2. User + Status: "Show unlocked achievements" or "Show in-progress achievements"
  // 3. Achievement + User: Enforce unique constraint (one progress record per user per achievement, unless repeatable)
  // 4. Unlock date queries: "Show recent unlocks" for notifications/leaderboards
  @@unique([achievementId, userId], name: "uq_user_achievements_achievement_user")
  @@index([userId, status], name: "idx_user_achievements_user_status")
  @@index([userId, unlockedAt], name: "idx_user_achievements_user_unlocked")
  @@index([achievementId], name: "idx_user_achievements_achievement")
  @@map("user_achievements")
}

/// PasswordHistory entity - Tracks password changes for security compliance
/// ARCHITECTURAL DECISION: Password history for security requirements
/// - Store hashed passwords only (never plain text)
/// - Track password changes for compliance (e.g., "no reuse of last 5 passwords")
/// - Capture IP and user agent for security audit trails
/// - CASCADE delete when user deleted (privacy compliance)
model PasswordHistory {
  id String @id @default(uuid()) @db.Uuid

  // Password hash (bcrypt or argon2)
  // SECURITY: Never store plain text passwords
  // Same hashing algorithm as User.passwordHash
  passwordHash String @map("password_hash") @db.VarChar(255)

  // Security audit metadata
  // ARCHITECTURAL DECISION: Track change context for security
  // ipAddress: Client IP for geo-location analysis
  // userAgent: Browser/device fingerprinting
  ipAddress String? @map("ip_address") @db.VarChar(45) // IPv6 max length: 45
  userAgent String? @map("user_agent") @db.VarChar(255)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // User relation
  // ARCHITECTURAL DECISION: CASCADE delete
  // Rationale: When user deleted, password history should be purged (privacy)
  // No orphaned password history records
  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for query performance
  // ARCHITECTURAL DECISION: Composite index (userId, createdAt)
  // Query pattern: "Get last N password hashes for user X"
  // Enables efficient password reuse checks
  @@index([userId, createdAt], name: "idx_password_history_user_created")
  @@map("password_history")
}

/// AuditLog entity - Security and activity event tracking
/// ARCHITECTURAL DECISION: Comprehensive audit trail
/// - Track all security-sensitive events (login, password, account changes)
/// - Support forensic analysis (IP, user agent, timestamps)
/// - Enable compliance reporting (PCI-DSS, SOC2, GDPR)
/// - userId nullable for system-level events (e.g., failed login without user match)
model AuditLog {
  id String @id @default(uuid()) @db.Uuid

  // Event classification
  // ARCHITECTURAL DECISION: Enum for type safety and indexing
  // Ensures consistent event naming across application
  eventType AuditEventType @map("event_type")

  // Event description
  // ARCHITECTURAL DECISION: Human-readable description
  // Examples: "User changed password", "Login failed: invalid credentials"
  description String @db.VarChar(255)

  // Security context
  // ARCHITECTURAL DECISION: Track origin of event
  // ipAddress: Detect unusual locations, rate limiting
  // userAgent: Device fingerprinting, bot detection
  ipAddress String? @map("ip_address") @db.VarChar(45)
  userAgent String? @map("user_agent") @db.VarChar(255)

  // Additional event metadata stored as JSONB
  // ARCHITECTURAL DECISION: Flexible metadata structure
  // Different event types have different metadata needs
  // Examples:
  //   PASSWORD_CHANGED: { passwordStrength: 85 }
  //   LOGIN_FAILED: { failureReason: "invalid_password", attemptCount: 3 }
  //   LOGIN_LOCKED: { lockoutDuration: 900, unlockAt: "2025-10-12T15:30:00Z" }
  //   PASSWORD_RESET_REQUESTED: { resetTokenExpiry: "2025-10-12T14:00:00Z" }
  metadata Json? @db.JsonB

  // Security flag
  // ARCHITECTURAL DECISION: Pre-filter high-priority events
  // Rationale: Enable efficient queries for security monitoring
  // Example: Alert on all isSecurityEvent=true in last 24h
  isSecurityEvent Boolean @default(false) @map("is_security_event")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // User relation (nullable for system events)
  // ARCHITECTURAL DECISION: Nullable userId
  // Rationale: Some events occur without identified user
  // Examples: Failed login with non-existent email, rate limit hit
  // CASCADE delete: User deletion removes their audit trail (privacy)
  userId String? @map("user_id") @db.Uuid
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for query performance
  // ARCHITECTURAL DECISION: Multiple index strategies
  // 1. User timeline: (userId, eventType, createdAt) for "user activity history"
  // 2. Event monitoring: (eventType, createdAt) for "all LOGIN_FAILED in last hour"
  // 3. IP analysis: (ipAddress, createdAt) for "all events from IP X"
  // 4. Security alerts: (isSecurityEvent, createdAt) for monitoring dashboard
  @@index([userId, eventType, createdAt], name: "idx_audit_logs_user_event_created")
  @@index([eventType, createdAt], name: "idx_audit_logs_event_created")
  @@index([ipAddress, createdAt], name: "idx_audit_logs_ip_created")
  @@index([isSecurityEvent, createdAt], name: "idx_audit_logs_security_created")
  @@map("audit_logs")
}

/// BankingCustomer entity - SaltEdge v6 requires customer management
/// ARCHITECTURAL DECISION: Separate customer record per provider
/// - Customer is created once per user per provider (SaltEdge v6 requirement)
/// - Stores provider-specific customer ID for all subsequent API calls
/// - Each customer can have multiple connections (banks)
model BankingCustomer {
  id              String          @id @default(uuid()) @db.Uuid
  userId          String          @map("user_id") @db.Uuid
  provider        BankingProvider @default(SALTEDGE)

  // Provider-specific customer identifiers
  saltEdgeCustomerId    String?   @unique @map("saltedge_customer_id") @db.VarChar(255)
  tinkCustomerId        String?   @unique @map("tink_customer_id") @db.VarChar(255)
  yapilyCustomerId      String?   @unique @map("yapily_customer_id") @db.VarChar(255)

  // Customer identifier sent to provider (hashed user email or UUID)
  identifier      String          @db.VarChar(255)

  // Status
  isActive        Boolean         @default(true) @map("is_active")

  // Timestamps
  createdAt       DateTime        @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime        @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  connections     BankingConnection[]

  // Indexes
  @@unique([userId, provider], name: "uq_banking_customer_user_provider")
  @@index([provider, isActive], name: "idx_banking_customer_provider_active")
  @@map("banking_customers")
}

/// BankingConnection entity - Tracks OAuth flow and banking provider links
/// ARCHITECTURAL DECISION: Separate from Account for OAuth state tracking
/// - Connection tracks the OAuth link (redirect URLs, status, expiration)
/// - Account records the linked accounts and their data
/// - One Connection can result in multiple Account records
model BankingConnection {
  id                String                    @id @default(uuid()) @db.Uuid
  userId            String                    @map("user_id") @db.Uuid
  customerId        String?                   @map("customer_id") @db.Uuid
  provider          BankingProvider
  status            BankingConnectionStatus   @default(PENDING)

  // Provider-specific identifiers
  // SaltEdge
  saltEdgeConnectionId  String?               @unique @map("saltedge_connection_id") @db.VarChar(255)
  // Tink (Phase 2)
  tinkConnectionId      String?               @unique @map("tink_connection_id") @db.VarChar(255)
  // Yapily (Phase 3)
  yalilyConnectionId    String?               @unique @map("yapily_connection_id") @db.VarChar(255)

  // Provider name/code (e.g., "fakebank_simple_xf", "intesa_sanpaolo_it")
  providerCode      String?                   @map("provider_code") @db.VarChar(255)
  providerName      String?                   @map("provider_name") @db.VarChar(255)
  countryCode       String?                   @map("country_code") @db.VarChar(10)

  // OAuth flow tracking
  redirectUrl       String?                   @map("redirect_url") @db.Text
  authorizationUrl  String?                   @map("authorization_url") @db.Text
  expiresAt         DateTime?                 @map("expires_at") @db.Timestamptz
  authorizedAt      DateTime?                 @map("authorized_at") @db.Timestamptz

  // Last successful sync tracking
  lastSuccessAt     DateTime?                 @map("last_success_at") @db.Timestamptz
  nextRefreshAt     DateTime?                 @map("next_refresh_at") @db.Timestamptz

  // Provider metadata
  metadata          Json?                     @db.JsonB  // Provider-specific data

  // Timestamps
  createdAt         DateTime                  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt         DateTime                  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user              User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  customer          BankingCustomer?          @relation(fields: [customerId], references: [id], onDelete: SetNull)

  // Indexes
  @@unique([userId, saltEdgeConnectionId], name: "uq_banking_conn_user_saltedge")
  @@index([userId, status], name: "idx_banking_conn_user_status")
  @@index([customerId], name: "idx_banking_conn_customer")
  @@index([provider, status], name: "idx_banking_conn_provider_status")
  @@index([expiresAt], name: "idx_banking_conn_expires")
  @@map("banking_connections")
}

/// BankingSyncLog entity - Audit trail for account synchronization
/// ARCHITECTURAL DECISION: Immutable sync history for debugging and monitoring
/// - Records every sync attempt (success and failure)
/// - Enables monitoring of sync health and troubleshooting
/// - Supports analytics (sync patterns, error rates, performance)
model BankingSyncLog {
  id                String                    @id @default(uuid()) @db.Uuid
  accountId         String                    @map("account_id") @db.Uuid
  provider          BankingProvider
  status            BankingSyncStatus

  // Sync timing
  startedAt         DateTime                  @default(now()) @map("started_at") @db.Timestamptz
  completedAt       DateTime?                 @map("completed_at") @db.Timestamptz

  // Results
  accountsSynced    Int?                      @map("accounts_synced")
  transactionsSynced Int?                     @map("transactions_synced")
  balanceUpdated    Boolean                   @default(false) @map("balance_updated")

  // Error tracking
  error             String?                   @map("error") @db.Text
  errorCode         String?                   @map("error_code") @db.VarChar(50)

  // Metadata
  metadata          Json?                     @db.JsonB  // Provider-specific sync details

  // Relations
  account           Account                   @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([accountId, startedAt], name: "idx_sync_logs_account_date")
  @@index([provider, status], name: "idx_sync_logs_provider_status")
  @@index([status, startedAt], name: "idx_sync_logs_status_date")
  @@map("banking_sync_logs")
}

// ============================================================================
// PHASE 0 - NEW MODELS
// ============================================================================

/// UserPreferences entity - User-specific settings and customization
/// ARCHITECTURAL DECISION: Separate from User model for clarity
/// - User model contains identity data (name, email, auth)
/// - UserPreferences contains customization (timezone, locale, notification settings)
/// - One-to-one relationship, created on user signup
model UserPreferences {
  id     String @id @default(uuid()) @db.Uuid
  userId String @unique @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Localization settings
  timezone   String @default("UTC") @db.VarChar(50)
  currency   String @default("USD") @db.VarChar(3)
  dateFormat String @default("YYYY-MM-DD") @map("date_format") @db.VarChar(20)
  locale     String @default("en-US") @db.VarChar(10)

  // Notification preferences
  emailNotifications Boolean @default(true) @map("email_notifications")
  pushNotifications  Boolean @default(true) @map("push_notifications")
  budgetAlerts       Boolean @default(true) @map("budget_alerts")
  billReminders      Boolean @default(true) @map("bill_reminders")
  weeklyDigest       Boolean @default(true) @map("weekly_digest")

  // UI preferences stored as JSONB
  // Expected shape: { theme: 'light'|'dark'|'system', compactView, showBalances, defaultAccountId }
  uiPreferences Json? @map("ui_preferences") @db.JsonB

  // Financial preferences stored as JSONB
  // Expected shape: { defaultBudgetPeriod, startOfWeek, fiscalYearStart }
  financialPreferences Json? @map("financial_preferences") @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@map("user_preferences")
}

/// Notification entity - In-app and push notifications
/// ARCHITECTURAL DECISION: Server-managed notifications
/// - Notifications created by backend based on events
/// - Supports multiple delivery channels (in-app, push, email)
/// - User can dismiss or mark as read
model Notification {
  id       String               @id @default(uuid()) @db.Uuid
  userId   String               @map("user_id") @db.Uuid
  type     NotificationType
  priority NotificationPriority @default(MEDIUM)
  status   NotificationStatus   @default(PENDING)

  // Content
  title   String  @db.VarChar(255)
  message String  @db.Text
  link    String? @db.VarChar(500) // Deep link to relevant content

  // Delivery tracking
  sentAt      DateTime? @map("sent_at") @db.Timestamptz
  readAt      DateTime? @map("read_at") @db.Timestamptz
  dismissedAt DateTime? @map("dismissed_at") @db.Timestamptz

  // Context metadata stored as JSONB
  // Expected shape varies by type:
  //   BUDGET_ALERT: { categoryId, budgetId, percentUsed, threshold }
  //   BILL_REMINDER: { liabilityId, amount, dueDate }
  //   TRANSACTION_ALERT: { transactionId, amount, reason }
  metadata Json? @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Indexes
  @@index([userId, status], name: "idx_notifications_user_status")
  @@index([userId, createdAt], name: "idx_notifications_user_created")
  @@index([type, status], name: "idx_notifications_type_status")
  @@map("notifications")
}

/// PushSubscription entity - Web Push API subscriptions
/// ARCHITECTURAL DECISION: Store push endpoints per device
/// - Users may have multiple devices (web browser, mobile)
/// - Each device gets its own subscription endpoint
/// - Expired/invalid subscriptions cleaned up on push failure
model PushSubscription {
  id       String @id @default(uuid()) @db.Uuid
  userId   String @map("user_id") @db.Uuid
  endpoint String @unique @db.Text

  // Push subscription keys (from browser Push API)
  p256dh String @db.VarChar(255)
  auth   String @db.VarChar(255)

  // Device info for debugging
  userAgent  String? @map("user_agent") @db.VarChar(500)
  deviceName String? @map("device_name") @db.VarChar(100)

  // Status tracking
  isActive       Boolean   @default(true) @map("is_active")
  lastUsedAt     DateTime? @map("last_used_at") @db.Timestamptz
  failedAttempts Int       @default(0) @map("failed_attempts")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Indexes
  @@index([userId, isActive], name: "idx_push_subscriptions_user_active")
  @@map("push_subscriptions")
}

/// Liability entity - Credit cards, BNPL, loans, and other debts
/// ARCHITECTURAL DECISION: Separate from Account for specialized tracking
/// - Liabilities have different lifecycle (due dates, cycles, installments)
/// - Can be linked to an Account (credit card account) or standalone (BNPL)
/// - Supports both revolving (credit card) and installment (BNPL) debts
model Liability {
  id       String          @id @default(uuid()) @db.Uuid
  familyId String          @map("family_id") @db.Uuid
  family   Family          @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // Classification
  type   LiabilityType
  status LiabilityStatus @default(ACTIVE)
  name   String          @db.VarChar(255)

  // Balance tracking
  currentBalance  Decimal  @default(0) @map("current_balance") @db.Decimal(15, 2)
  creditLimit     Decimal? @map("credit_limit") @db.Decimal(15, 2)
  originalAmount  Decimal? @map("original_amount") @db.Decimal(15, 2) // For loans/BNPL
  currency        String   @default("USD") @db.VarChar(3)

  // Interest and fees
  interestRate   Decimal? @map("interest_rate") @db.Decimal(5, 2) // APR as percentage
  minimumPayment Decimal? @map("minimum_payment") @db.Decimal(15, 2)

  // Billing cycle (for credit cards)
  billingCycleDay   Int?      @map("billing_cycle_day") // Day of month (1-31)
  paymentDueDay     Int?      @map("payment_due_day") // Day of month (1-31)
  statementCloseDay Int?      @map("statement_close_day") // Day of month
  lastStatementDate DateTime? @map("last_statement_date") @db.Date

  // Optional link to Account
  // ARCHITECTURAL DECISION: Nullable accountId
  // Some liabilities (BNPL) don't have corresponding accounts
  accountId String?  @map("account_id") @db.Uuid
  account   Account? @relation(fields: [accountId], references: [id], onDelete: SetNull)

  // Provider info (for BNPL)
  provider     String? @db.VarChar(100) // "Klarna", "PayPal Pay-in-3", "Affirm"
  externalId   String? @map("external_id") @db.VarChar(255)
  purchaseDate DateTime? @map("purchase_date") @db.Date

  // Metadata stored as JSONB
  // Expected shape: { description, notes, autoPayEnabled, lastPaymentDate }
  metadata Json? @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  installmentPlans InstallmentPlan[]

  // Indexes
  @@index([familyId, status], name: "idx_liabilities_family_status")
  @@index([familyId, type], name: "idx_liabilities_family_type")
  @@index([accountId], name: "idx_liabilities_account")
  @@map("liabilities")
}

/// InstallmentPlan entity - Fixed payment schedules for BNPL and loans
/// ARCHITECTURAL DECISION: Separate model for installment tracking
/// - Each BNPL purchase or loan has a fixed payment schedule
/// - Tracks individual installments with status
/// - Enables payment calendar view and reminder scheduling
model InstallmentPlan {
  id          String    @id @default(uuid()) @db.Uuid
  liabilityId String    @map("liability_id") @db.Uuid
  liability   Liability @relation(fields: [liabilityId], references: [id], onDelete: Cascade)

  // Plan details
  totalAmount         Decimal @map("total_amount") @db.Decimal(15, 2)
  installmentAmount   Decimal @map("installment_amount") @db.Decimal(15, 2)
  numberOfInstallments Int    @map("number_of_installments")
  remainingInstallments Int   @default(0) @map("remaining_installments")
  currency            String  @default("USD") @db.VarChar(3)

  // Schedule
  startDate DateTime @map("start_date") @db.Date
  endDate   DateTime @map("end_date") @db.Date

  // Status
  isPaidOff Boolean @default(false) @map("is_paid_off")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  installments Installment[]

  // Indexes
  @@index([liabilityId], name: "idx_installment_plans_liability")
  @@map("installment_plans")
}

/// Installment entity - Individual payments in an installment plan
/// ARCHITECTURAL DECISION: Track each payment separately
/// - Enables precise tracking of paid vs due installments
/// - Links to actual transaction when paid
model Installment {
  id     String          @id @default(uuid()) @db.Uuid
  planId String          @map("plan_id") @db.Uuid
  plan   InstallmentPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  // Payment details
  amount          Decimal  @db.Decimal(15, 2)
  dueDate         DateTime @map("due_date") @db.Date
  installmentNumber Int    @map("installment_number") // 1, 2, 3...

  // Status
  isPaid Boolean   @default(false) @map("is_paid")
  paidAt DateTime? @map("paid_at") @db.Timestamptz

  // Link to actual payment transaction (when paid)
  transactionId String? @map("transaction_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Indexes
  @@index([planId, dueDate], name: "idx_installments_plan_due")
  @@index([dueDate, isPaid], name: "idx_installments_due_status")
  @@map("installments")
}

/// ScheduledTransaction entity - Recurring bills and scheduled payments
/// ARCHITECTURAL DECISION: Template-based scheduling
/// - ScheduledTransaction is the template (what to pay, how much)
/// - RecurrenceRule defines when (every month, every week, etc.)
/// - Actual transactions created when due date arrives
model ScheduledTransaction {
  id        String                     @id @default(uuid()) @db.Uuid
  familyId  String                     @map("family_id") @db.Uuid
  family    Family                     @relation(fields: [familyId], references: [id], onDelete: Cascade)
  accountId String                     @map("account_id") @db.Uuid
  status    ScheduledTransactionStatus @default(ACTIVE)

  // Transaction template
  amount       Decimal         @db.Decimal(15, 2)
  type         TransactionType
  flowType     FlowType?       @map("flow_type")
  currency     String          @default("USD") @db.VarChar(3)
  description  String          @db.VarChar(500)
  merchantName String?         @map("merchant_name") @db.VarChar(255)
  categoryId   String?         @map("category_id") @db.Uuid

  // Scheduling
  nextDueDate    DateTime  @map("next_due_date") @db.Date
  lastExecutedAt DateTime? @map("last_executed_at") @db.Timestamptz

  // Auto-create flag
  // ARCHITECTURAL DECISION: Support both reminder and auto-create modes
  // autoCreate=true: Transaction created automatically on due date
  // autoCreate=false: Just send reminder notification
  autoCreate Boolean @default(false) @map("auto_create")

  // Reminder settings
  reminderDaysBefore Int @default(3) @map("reminder_days_before")

  // Metadata stored as JSONB
  // Expected shape: { notes, tags, confirmBeforeCreate }
  metadata Json? @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  recurrenceRule RecurrenceRule?

  // Indexes
  @@index([familyId, status], name: "idx_scheduled_tx_family_status")
  @@index([nextDueDate, status], name: "idx_scheduled_tx_due_status")
  @@index([accountId], name: "idx_scheduled_tx_account")
  @@map("scheduled_transactions")
}

/// RecurrenceRule entity - Defines recurrence pattern
/// ARCHITECTURAL DECISION: Flexible recurrence model
/// - Supports common patterns (monthly, weekly) and complex (biweekly, quarterly)
/// - Uses RFC 5545 (iCal) inspired design
/// - Can have end date or occurrence count, or neither (infinite)
model RecurrenceRule {
  id                     String              @id @default(uuid()) @db.Uuid
  scheduledTransactionId String              @unique @map("scheduled_transaction_id") @db.Uuid
  scheduledTransaction   ScheduledTransaction @relation(fields: [scheduledTransactionId], references: [id], onDelete: Cascade)

  // Frequency
  frequency RecurrenceFrequency
  interval  Int                 @default(1) // Every N periods (e.g., every 2 weeks)

  // Day specification
  // For WEEKLY: 0-6 (Sunday-Saturday)
  // For MONTHLY: 1-31 (day of month) or -1 (last day)
  dayOfWeek  Int? @map("day_of_week")
  dayOfMonth Int? @map("day_of_month")

  // End conditions (all nullable = infinite)
  endDate   DateTime? @map("end_date") @db.Date
  endCount  Int?      @map("end_count") // After N occurrences

  // Tracking
  occurrenceCount Int @default(0) @map("occurrence_count") // How many have occurred

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@map("recurrence_rules")
}

// ============================================================================
// ARCHITECTURAL DECISIONS SUMMARY
// ============================================================================

// 1. CASCADE BEHAVIOR
//    - Family deleted → Users CASCADE deleted
//      Rationale: Family is the core organizational unit. When a family account
//      is closed, all associated users should be removed to maintain data integrity.
//      Users cannot exist without a family in MoneyWise's model.
//    - User deleted → Accounts CASCADE deleted
//      Rationale: Accounts are personally owned. When user leaves, their accounts go too.
//    - Account deleted → Transactions CASCADE deleted
//      Rationale: Transactions cannot exist without parent account. When account
//      is closed, transaction history is removed. Export data before deletion.
//    - Category deleted → Transaction.categoryId SET NULL
//      Rationale: Category is optional classification. Transactions remain valid
//      without categorization, just become "uncategorized."
//
// 2. REQUIRED familyId
//    - Every user MUST belong to a family (no nullable familyId)
//    - Solo users get auto-created single-member families on signup
//    - Simplifies authorization: check family membership instead of "user OR family" logic
//    - Aligns with core product vision: multi-generational finance platform
//
// 3. ROLE ENUM CHANGES
//    - TypeORM: USER/ADMIN (system-level roles)
//    - Prisma: ADMIN/MEMBER/VIEWER (family-level roles)
//    - Rationale: Roles now represent permission within a family, not system access
//    - ADMIN: Can manage family settings, invite/remove members, view all data
//    - MEMBER: Standard user with full access to their own data + shared family data
//    - VIEWER: Read-only (designed for children learning finance)
//
// 4. NAMING CONVENTIONS
//    - Database: snake_case (PostgreSQL standard)
//    - Application: camelCase (TypeScript standard)
//    - Use @map for column names, @@map for table names
//    - Maintains clean separation between DB and app layers
//
// 5. DECIMAL VS FLOAT FOR MONEY
//    - All money fields use Decimal type with @db.Decimal(15, 2)
//    - Rationale: Float/Double precision errors are unacceptable for financial data
//    - Example: 0.1 + 0.2 = 0.30000000000000004 in binary floating point
//    - Decimal stores exact values using fixed-point arithmetic
//    - Precision 15,2: Max value $9,999,999,999,999.99 (sufficient for personal finance)
//    - Application layer: Use Decimal.js or similar for calculations
//
// 6. JSONB FOR FLEXIBLE METADATA
//    - Used for: plaidMetadata, location, tags, attachments, splitDetails, settings
//    - Rationale: These structures evolve over time (especially Plaid API changes)
//    - JSONB provides flexibility without schema migrations
//    - Application layer handles validation via TypeScript types (Zod schemas)
//    - PostgreSQL JSONB supports GIN indexes if JSON querying becomes necessary
//    - Trade-off: Flexibility vs type safety (accept for auxiliary data)
//
// 7. DUAL OWNERSHIP MODEL (Accounts)
//    - Accounts can be owned by User OR Family (both nullable)
//    - Enables personal accounts (userId) and shared family accounts (familyId)
//    - Application logic must enforce XOR: exactly one is set, never both or neither
//    - Consider adding DB check constraint in migration:
//      CHECK ((user_id IS NULL) != (family_id IS NULL))
//    - Prisma does not support native XOR constraints in schema
//
// 8. TRANSACTION AMOUNT STORAGE
//    - Amount stored as absolute value (never negative)
//    - Type field (DEBIT/CREDIT) determines flow direction
//    - Rationale: Simplifies aggregation queries and prevents sign confusion
//    - Application layer computes displayAmount (negative for expenses)
//    - Example: $50 grocery expense: amount=50.00, type=DEBIT, displayAmount=-50.00
//
// 9. DATE VS TIMESTAMP FIELDS
//    - Transaction.date: DATE type (day-level granularity for reporting)
//    - Transaction.authorizedDate: TIMESTAMPTZ (exact time for Plaid data)
//    - Rationale: Financial reports group by day, not time
//    - Preserves exact timestamp for audit trails when available
//    - All other timestamps: TIMESTAMPTZ for timezone-aware tracking
//
// 10. INDEXES FOR TIME-SERIES QUERIES
//     - All transaction indexes include date as second column
//     - Rationale: Time-range queries are primary access pattern
//     - Examples: "Last 30 days", "This month", "Year-to-date"
//     - Composite indexes (entity, date) enable efficient range scans
//     - Index on (amount, date) for large transaction alerts
//     - Index on (merchantName, date) for spending pattern analysis
//
// 11. UNIQUE CONSTRAINTS FOR PLAID
//     - Account.plaidAccountId: UNIQUE (prevent duplicate connections)
//     - Transaction.plaidTransactionId: UNIQUE (prevent duplicate imports)
//     - Rationale: Plaid IDs are globally unique, enforce at DB level
//     - Handles sync failures gracefully (constraint violation = already synced)
//
// 12. VIRTUAL PROPERTIES STRATEGY
//     - TypeORM entities have getter methods (isExpense, displayAmount, etc.)
//     - Prisma does not support virtual properties in schema
//     - Rationale: Computed values belong in application layer, not database
//     - Implementation: Create helper functions or class methods in service layer
//     - Example: formatTransaction(tx) returns tx with computed properties
//
// 13. TRANSACTION IMMUTABILITY
//     - Transactions should not be deleted, only marked CANCELLED
//     - Rationale: Financial audit trails require complete history
//     - Exception: CASCADE delete when parent Account deleted (account closure)
//     - For corrections: Create offsetting transaction, don't modify original
//     - Application layer enforces this policy
//
// 14. CATEGORY OPTIONAL
//     - Transaction.categoryId is nullable
//     - Rationale: Categorization is user preference, not requirement
//     - Transactions valid without category (import, initial sync)
//     - Application can auto-categorize or prompt user
//     - SET NULL when category deleted maintains transaction validity
