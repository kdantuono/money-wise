// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

/// User role within a family context
/// ADMIN: Full family management (billing, member management, settings)
/// MEMBER: Standard access (manage own data, view family data)
/// VIEWER: Read-only access (good for children learning about finances)
enum UserRole {
  ADMIN
  MEMBER
  VIEWER

  @@map("user_role")
}

/// User account status
/// ACTIVE: Normal operation
/// INACTIVE: Temporarily disabled (e.g., parent disables child account)
/// SUSPENDED: System-level suspension (security/policy violation)
enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED

  @@map("user_status")
}

/// Financial account type
/// Maps to standard banking account categories
enum AccountType {
  CHECKING
  SAVINGS
  CREDIT_CARD
  INVESTMENT
  LOAN
  MORTGAGE
  OTHER

  @@map("account_type")
}

/// Account operational status
/// ACTIVE: Normal operation, syncing enabled
/// INACTIVE: User-disabled, no syncing
/// CLOSED: Permanently closed account
/// ERROR: Sync/connection error, needs attention
enum AccountStatus {
  ACTIVE
  INACTIVE
  CLOSED
  ERROR

  @@map("account_status")
}

/// Account data source
/// PLAID: Synced via Plaid API
/// MANUAL: User-entered data
enum AccountSource {
  PLAID
  MANUAL

  @@map("account_source")
}

/// Transaction type
/// DEBIT: Money out (expenses, withdrawals)
/// CREDIT: Money in (income, deposits)
enum TransactionType {
  DEBIT
  CREDIT

  @@map("transaction_type")
}

/// Transaction processing status
/// PENDING: Not yet cleared/posted
/// POSTED: Cleared and finalized
/// CANCELLED: Transaction reversed/cancelled
enum TransactionStatus {
  PENDING
  POSTED
  CANCELLED

  @@map("transaction_status")
}

/// Transaction data source
/// PLAID: Auto-synced via Plaid API
/// MANUAL: User-entered transaction
/// IMPORT: Bulk imported (CSV, etc.)
enum TransactionSource {
  PLAID
  MANUAL
  IMPORT

  @@map("transaction_source")
}

// ============================================================================
// MODELS
// ============================================================================

/// Family entity - Core organizational unit for MoneyWise
/// Represents a household/family group with shared financial management
model Family {
  id        String   @id @default(uuid()) @db.Uuid
  name      String   @db.VarChar(255)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  users    User[]
  accounts Account[]

  @@map("families")
}

/// User entity - Individual user within a family
/// Migrated from TypeORM with family relationship added
model User {
  id              String     @id @default(uuid()) @db.Uuid
  email           String     @unique @db.VarChar(255)
  firstName       String     @map("first_name") @db.VarChar(255)
  lastName        String     @map("last_name") @db.VarChar(255)
  passwordHash    String     @map("password_hash") @db.VarChar(255)
  role            UserRole   @default(MEMBER)
  status          UserStatus @default(ACTIVE)
  avatar          String?    @db.VarChar(255)
  timezone        String?    @db.VarChar(50)
  currency        String     @default("USD") @db.VarChar(3)
  preferences     Json?      @db.JsonB
  lastLoginAt     DateTime?  @map("last_login_at") @db.Timestamptz
  emailVerifiedAt DateTime?  @map("email_verified_at") @db.Timestamptz
  createdAt       DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime   @updatedAt @map("updated_at") @db.Timestamptz

  // Family relationship
  // ARCHITECTURAL DECISION: familyId is REQUIRED
  // Rationale: MoneyWise is "family-first" - every user must belong to a family
  // Solo users automatically get a single-member family on signup
  // This ensures consistent data model and simplifies authorization logic
  familyId String @map("family_id") @db.Uuid
  family   Family @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // Relations
  // ARCHITECTURAL DECISION: User → Account relationship maintained
  // Users own their personal accounts, but family also has shared accounts
  // This enables both individual and family-level financial management
  accounts Account[]

  // Indexes for query performance
  @@index([email], name: "idx_users_email")
  @@index([familyId], name: "idx_users_family_id")
  @@index([status, createdAt], name: "idx_users_status_created")
  @@index([familyId, role], name: "idx_users_family_role")
  @@map("users")
}

/// Account entity - Financial account (bank, credit card, investment, etc.)
/// ARCHITECTURAL DECISION: Dual ownership model
/// - Personal accounts: userId set, familyId null
/// - Family accounts: familyId set, userId null
/// - Application layer enforces exactly one is set (XOR constraint)
/// - Enables both individual and shared family financial management
model Account {
  id   String @id @default(uuid()) @db.Uuid
  name String @db.VarChar(255)

  // Account classification
  type   AccountType   @default(OTHER)
  status AccountStatus @default(ACTIVE)
  source AccountSource

  // Balance tracking
  // ARCHITECTURAL DECISION: Use Decimal for money fields
  // Rationale: Float/Double precision errors are unacceptable for financial data
  // Example: 0.1 + 0.2 = 0.30000000000000004 in binary floating point
  // Decimal stores exact values, critical for money calculations
  currentBalance   Decimal  @default(0) @db.Decimal(15, 2)
  availableBalance Decimal? @db.Decimal(15, 2)
  creditLimit      Decimal? @db.Decimal(15, 2)
  currency         String   @default("USD") @db.VarChar(3)

  // Institution details
  institutionName String? @db.VarChar(255)
  accountNumber   String? @db.VarChar(255)
  routingNumber   String? @db.VarChar(255)

  // Plaid integration fields
  // ARCHITECTURAL DECISION: Store plaidAccessToken at account level
  // Rationale: One access token per Plaid Item (institution connection)
  // Multiple accounts can share same plaidItemId (e.g., checking + savings)
  plaidAccountId   String? @map("plaid_account_id") @db.VarChar(255)
  plaidItemId      String? @map("plaid_item_id") @db.VarChar(255)
  plaidAccessToken String? @map("plaid_access_token") @db.Text

  // Plaid metadata stored as JSONB
  // ARCHITECTURAL DECISION: Use JSONB instead of separate columns
  // Rationale: Plaid metadata evolves, JSONB provides flexibility
  // Application layer handles schema validation via TypeScript types
  // Expected shape: { mask, subtype, officialName, persistentAccountId }
  plaidMetadata Json? @db.JsonB

  // Sync settings
  isActive    Boolean   @default(true) @map("is_active")
  syncEnabled Boolean   @default(true) @map("sync_enabled")
  lastSyncAt  DateTime? @map("last_sync_at") @db.Timestamptz
  syncError   String?   @map("sync_error") @db.VarChar(500)

  // Account preferences stored as JSONB
  // Expected shape: { autoSync, syncFrequency, notifications, budgetIncluded }
  settings Json? @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Dual ownership relations
  // ARCHITECTURAL DECISION: Both nullable, XOR enforced at application layer
  // Rationale: Prisma does not support native XOR constraints
  // Application must validate: (userId IS NULL) XOR (familyId IS NULL)
  // Consider adding DB check constraint in migration for data integrity
  userId String? @map("user_id") @db.Uuid
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  familyId String? @map("family_id") @db.Uuid
  family   Family? @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // Relations
  transactions Transaction[]

  @@unique([plaidAccountId], name: "uq_accounts_plaid_account")
  // Indexes for query performance
  // ARCHITECTURAL DECISION: Index strategy for common query patterns
  // 1. Ownership lookups: userId, familyId
  // 2. Account filtering: (userId/familyId, status) for "show active accounts"
  // 3. Plaid sync: plaidItemId for batch sync operations
  // 4. Unique Plaid IDs: Prevent duplicate connections
  @@index([userId], name: "idx_accounts_user_id")
  @@index([familyId], name: "idx_accounts_family_id")
  @@index([userId, status], name: "idx_accounts_user_status")
  @@index([familyId, status], name: "idx_accounts_family_status")
  @@index([plaidItemId], name: "idx_accounts_plaid_item")
  @@map("accounts")
}

/// Transaction entity - Individual financial transaction
/// ARCHITECTURAL DECISION: Immutable transaction history
/// - Transactions should not be deleted, only marked as CANCELLED
/// - Historical data is critical for financial reporting and auditing
/// - Exception: CASCADE delete when parent Account is deleted (account closure)
model Transaction {
  id String @id @default(uuid()) @db.Uuid

  // Amount and classification
  // ARCHITECTURAL DECISION: Store amount as absolute value
  // Rationale: Type field (DEBIT/CREDIT) determines flow direction
  // Application layer computes displayAmount (negative for expenses)
  // Simplifies aggregation queries: SUM(amount) WHERE type = 'DEBIT'
  amount   Decimal           @db.Decimal(15, 2)
  type     TransactionType
  status   TransactionStatus @default(POSTED)
  source   TransactionSource
  currency String            @default("USD") @db.VarChar(3)

  // Date tracking
  // ARCHITECTURAL DECISION: date as DATE, authorizedDate as TIMESTAMPTZ
  // Rationale: date is for financial reporting (day-level granularity)
  // authorizedDate preserves exact transaction time for Plaid data
  date           DateTime  @db.Date
  authorizedDate DateTime? @map("authorized_date") @db.Timestamptz

  // Description fields
  description         String  @db.VarChar(500)
  merchantName        String? @map("merchant_name") @db.VarChar(255)
  originalDescription String? @map("original_description") @db.VarChar(255)

  // Additional metadata
  reference   String? @db.VarChar(255)
  checkNumber String? @map("check_number") @db.VarChar(255)
  notes       String? @db.Text

  // Transaction flags
  isPending       Boolean @default(false) @map("is_pending")
  isRecurring     Boolean @default(false) @map("is_recurring")
  isHidden        Boolean @default(false) @map("is_hidden")
  includeInBudget Boolean @default(true) @map("include_in_budget")

  // Plaid integration fields
  plaidTransactionId String? @map("plaid_transaction_id") @db.VarChar(255)
  plaidAccountId     String? @map("plaid_account_id") @db.VarChar(255)

  // Complex metadata stored as JSONB
  // ARCHITECTURAL DECISION: Use JSONB for nested/evolving structures
  // Rationale: Plaid API provides rich metadata that changes over time
  // JSONB allows flexible storage without schema migrations
  // Application layer handles validation and type safety
  // PostgreSQL JSONB supports GIN indexes for JSON queries if needed

  // Plaid-specific metadata
  // Expected shape: { categoryId, categoryConfidenceLevel, transactionCode,
  //                   transactionType, locationId, merchantEntityId,
  //                   paymentChannel, authorizedDateTime, personalFinanceCategory }
  plaidMetadata Json? @db.JsonB

  // Location data (for merchant transactions)
  // Expected shape: { address, city, region, postalCode, country, lat, lon, storeNumber }
  location Json? @db.JsonB

  // User-defined tags (array of strings)
  // Expected shape: ["groceries", "work-expense", "reimbursable"]
  tags Json? @db.JsonB

  // File attachments (receipts, invoices)
  // Expected shape: [{ id, filename, mimetype, size, url }]
  attachments Json? @db.JsonB

  // Split transaction details
  // ARCHITECTURAL DECISION: Store split info in JSONB, not separate table
  // Rationale: Splits are uncommon, adding join complexity for rare case
  // JSONB keeps data co-located for better query performance
  // Expected shape: { isParent, parentId, splits: [{ amount, categoryId, description }] }
  splitDetails Json? @map("split_details") @db.JsonB

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  // ARCHITECTURAL DECISION: CASCADE delete when Account deleted
  // Rationale: Transactions cannot exist without parent account
  // When user closes account, transaction history goes with it
  // For data retention: Export transactions before account deletion
  accountId String  @map("account_id") @db.Uuid
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // ARCHITECTURAL DECISION: SET NULL when Category deleted
  // Rationale: Category is optional classification, not required parent
  // If user deletes category, transactions remain but lose categorization
  // Application can provide "uncategorized" filter for these transactions
  categoryId String? @map("category_id") @db.Uuid
  // Category relation will be added in P.1.4 when Category model is created
  // category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  @@unique([plaidTransactionId], name: "uq_transactions_plaid_id")
  // Indexes for query performance
  // ARCHITECTURAL DECISION: Time-series and filtering indexes
  // Common query patterns:
  // 1. Account transaction history: (accountId, date) for pagination
  // 2. Category spending reports: (categoryId, date) for time-range aggregation
  // 3. Status filtering: (status, date) for pending transaction views
  // 4. Merchant analysis: (merchantName, date) for spending patterns
  // 5. Amount queries: (amount, date) for large transaction alerts
  // 6. Plaid deduplication: UNIQUE on plaidTransactionId (when not null)
  @@index([accountId, date], name: "idx_transactions_account_date")
  @@index([categoryId, date], name: "idx_transactions_category_date")
  @@index([status, date], name: "idx_transactions_status_date")
  @@index([merchantName, date], name: "idx_transactions_merchant_date")
  @@index([amount, date], name: "idx_transactions_amount_date")
  @@map("transactions")
}

// ============================================================================
// ARCHITECTURAL DECISIONS SUMMARY
// ============================================================================

// 1. CASCADE BEHAVIOR
//    - Family deleted → Users CASCADE deleted
//      Rationale: Family is the core organizational unit. When a family account
//      is closed, all associated users should be removed to maintain data integrity.
//      Users cannot exist without a family in MoneyWise's model.
//    - User deleted → Accounts CASCADE deleted
//      Rationale: Accounts are personally owned. When user leaves, their accounts go too.
//    - Account deleted → Transactions CASCADE deleted
//      Rationale: Transactions cannot exist without parent account. When account
//      is closed, transaction history is removed. Export data before deletion.
//    - Category deleted → Transaction.categoryId SET NULL
//      Rationale: Category is optional classification. Transactions remain valid
//      without categorization, just become "uncategorized."
//
// 2. REQUIRED familyId
//    - Every user MUST belong to a family (no nullable familyId)
//    - Solo users get auto-created single-member families on signup
//    - Simplifies authorization: check family membership instead of "user OR family" logic
//    - Aligns with core product vision: multi-generational finance platform
//
// 3. ROLE ENUM CHANGES
//    - TypeORM: USER/ADMIN (system-level roles)
//    - Prisma: ADMIN/MEMBER/VIEWER (family-level roles)
//    - Rationale: Roles now represent permission within a family, not system access
//    - ADMIN: Can manage family settings, invite/remove members, view all data
//    - MEMBER: Standard user with full access to their own data + shared family data
//    - VIEWER: Read-only (designed for children learning finance)
//
// 4. NAMING CONVENTIONS
//    - Database: snake_case (PostgreSQL standard)
//    - Application: camelCase (TypeScript standard)
//    - Use @map for column names, @@map for table names
//    - Maintains clean separation between DB and app layers
//
// 5. DECIMAL VS FLOAT FOR MONEY
//    - All money fields use Decimal type with @db.Decimal(15, 2)
//    - Rationale: Float/Double precision errors are unacceptable for financial data
//    - Example: 0.1 + 0.2 = 0.30000000000000004 in binary floating point
//    - Decimal stores exact values using fixed-point arithmetic
//    - Precision 15,2: Max value $9,999,999,999,999.99 (sufficient for personal finance)
//    - Application layer: Use Decimal.js or similar for calculations
//
// 6. JSONB FOR FLEXIBLE METADATA
//    - Used for: plaidMetadata, location, tags, attachments, splitDetails, settings
//    - Rationale: These structures evolve over time (especially Plaid API changes)
//    - JSONB provides flexibility without schema migrations
//    - Application layer handles validation via TypeScript types (Zod schemas)
//    - PostgreSQL JSONB supports GIN indexes if JSON querying becomes necessary
//    - Trade-off: Flexibility vs type safety (accept for auxiliary data)
//
// 7. DUAL OWNERSHIP MODEL (Accounts)
//    - Accounts can be owned by User OR Family (both nullable)
//    - Enables personal accounts (userId) and shared family accounts (familyId)
//    - Application logic must enforce XOR: exactly one is set, never both or neither
//    - Consider adding DB check constraint in migration:
//      CHECK ((user_id IS NULL) != (family_id IS NULL))
//    - Prisma does not support native XOR constraints in schema
//
// 8. TRANSACTION AMOUNT STORAGE
//    - Amount stored as absolute value (never negative)
//    - Type field (DEBIT/CREDIT) determines flow direction
//    - Rationale: Simplifies aggregation queries and prevents sign confusion
//    - Application layer computes displayAmount (negative for expenses)
//    - Example: $50 grocery expense: amount=50.00, type=DEBIT, displayAmount=-50.00
//
// 9. DATE VS TIMESTAMP FIELDS
//    - Transaction.date: DATE type (day-level granularity for reporting)
//    - Transaction.authorizedDate: TIMESTAMPTZ (exact time for Plaid data)
//    - Rationale: Financial reports group by day, not time
//    - Preserves exact timestamp for audit trails when available
//    - All other timestamps: TIMESTAMPTZ for timezone-aware tracking
//
// 10. INDEXES FOR TIME-SERIES QUERIES
//     - All transaction indexes include date as second column
//     - Rationale: Time-range queries are primary access pattern
//     - Examples: "Last 30 days", "This month", "Year-to-date"
//     - Composite indexes (entity, date) enable efficient range scans
//     - Index on (amount, date) for large transaction alerts
//     - Index on (merchantName, date) for spending pattern analysis
//
// 11. UNIQUE CONSTRAINTS FOR PLAID
//     - Account.plaidAccountId: UNIQUE (prevent duplicate connections)
//     - Transaction.plaidTransactionId: UNIQUE (prevent duplicate imports)
//     - Rationale: Plaid IDs are globally unique, enforce at DB level
//     - Handles sync failures gracefully (constraint violation = already synced)
//
// 12. VIRTUAL PROPERTIES STRATEGY
//     - TypeORM entities have getter methods (isExpense, displayAmount, etc.)
//     - Prisma does not support virtual properties in schema
//     - Rationale: Computed values belong in application layer, not database
//     - Implementation: Create helper functions or class methods in service layer
//     - Example: formatTransaction(tx) returns tx with computed properties
//
// 13. TRANSACTION IMMUTABILITY
//     - Transactions should not be deleted, only marked CANCELLED
//     - Rationale: Financial audit trails require complete history
//     - Exception: CASCADE delete when parent Account deleted (account closure)
//     - For corrections: Create offsetting transaction, don't modify original
//     - Application layer enforces this policy
//
// 14. CATEGORY OPTIONAL
//     - Transaction.categoryId is nullable
//     - Rationale: Categorization is user preference, not requirement
//     - Transactions valid without category (import, initial sync)
//     - Application can auto-categorize or prompt user
//     - SET NULL when category deleted maintains transaction validity
