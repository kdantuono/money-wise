# MoneyWise CI/CD Pipeline
# Comprehensive testing, security scanning, and deployment workflow
# Maintained by: Senior Tester Architect & CI/CD Engineer

# Global Variables
variables:
  # Node.js Configuration
  NODE_VERSION: '18.17.0'
  NPM_CONFIG_CACHE: '$CI_PROJECT_DIR/.npm'

  # Docker Configuration
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: '/certs'

  # Testing Configuration
  COVERAGE_THRESHOLD: '80'
  PERFORMANCE_BUDGET: '3000' # 3 seconds
  ACCESSIBILITY_THRESHOLD: '100' # WCAG 2.1 AA compliance

  # Security Configuration
  SAST_EXCLUDED_ANALYZERS: 'eslint'
  SECRET_DETECTION_EXCLUDED_PATHS: 'node_modules/'

  # Quality Gates
  SONAR_USER_HOME: '${CI_PROJECT_DIR}/.sonar'

  # Environment URLs
  STAGING_URL: 'https://staging-money-wise.example.com'
  PRODUCTION_URL: 'https://money-wise.example.com'

# Pipeline Stages
stages:
  - validate
  - test
  - build
  - security
  - quality
  - deploy-staging
  - e2e-tests
  - deploy-production
  - monitor

# Global Cache Configuration
cache:
  key:
    files:
      - package-lock.json
      - apps/web/package-lock.json
      - apps/backend/package-lock.json
  paths:
    - .npm/
    - node_modules/
    - apps/web/node_modules/
    - apps/backend/node_modules/

# Before Script
before_script:
  - echo "Starting MoneyWise CI/CD Pipeline"
  - node --version
  - npm --version

# ================================
# VALIDATION STAGE
# ================================

validate:dependencies:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - echo "üîç Validating dependencies and security"
    - npm ci --prefer-offline --no-audit
    - npm audit --audit-level moderate
    - npm run setup
  artifacts:
    expire_in: 1 hour
    paths:
      - node_modules/
      - apps/web/node_modules/
      - apps/backend/node_modules/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

validate:lint:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  needs: ['validate:dependencies']
  script:
    - echo "üìã Running linting and code style checks"
    - npm run lint
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

validate:types:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  needs: ['validate:dependencies']
  script:
    - echo "üîç Type checking TypeScript code"
    - cd apps/web && npm run type-check
    - cd ../backend && npx tsc --noEmit
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# TESTING STAGE
# ================================

test:unit:frontend:
  stage: test
  image: node:${NODE_VERSION}-alpine
  needs: ['validate:dependencies']
  script:
    - echo "üß™ Running frontend unit tests"
    - cd apps/web
    - npm run test:unit
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    expire_in: 1 week
    reports:
      coverage_report:
        coverage_format: cobertura
        path: apps/web/coverage/cobertura-coverage.xml
      junit: apps/web/coverage/junit.xml
    paths:
      - apps/web/coverage/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:unit:backend:
  stage: test
  image: node:${NODE_VERSION}-alpine
  needs: ['validate:dependencies']
  services:
    - postgres:15-alpine
    - redis:7-alpine
  variables:
    POSTGRES_DB: test_moneywise
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DB_HOST: postgres
    DB_PORT: 5432
    DB_USERNAME: test_user
    DB_PASSWORD: test_password
    DB_NAME: test_moneywise
    REDIS_HOST: redis
    REDIS_PORT: 6379
    NODE_ENV: test
  script:
    - echo "üß™ Running backend unit tests"
    - cd apps/backend
    - npm run test
    - npm run test:cov
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    expire_in: 1 week
    reports:
      coverage_report:
        coverage_format: cobertura
        path: apps/backend/coverage/cobertura-coverage.xml
      junit: apps/backend/coverage/junit.xml
    paths:
      - apps/backend/coverage/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:integration:frontend:
  stage: test
  image: node:${NODE_VERSION}-alpine
  needs: ['validate:dependencies']
  script:
    - echo "üîó Running frontend integration tests"
    - cd apps/web
    - npm run test:integration
  artifacts:
    expire_in: 1 week
    reports:
      junit: apps/web/test-results/integration-results.xml
    paths:
      - apps/web/test-results/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:integration:backend:
  stage: test
  image: node:${NODE_VERSION}-alpine
  needs: ['validate:dependencies']
  services:
    - postgres:15-alpine
    - redis:7-alpine
  variables:
    POSTGRES_DB: test_moneywise
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DB_HOST: postgres
    DB_PORT: 5432
    DB_USERNAME: test_user
    DB_PASSWORD: test_password
    DB_NAME: test_moneywise
    REDIS_HOST: redis
    REDIS_PORT: 6379
    NODE_ENV: test
  script:
    - echo "üîó Running backend integration tests"
    - cd apps/backend
    - npm run test:e2e
  artifacts:
    expire_in: 1 week
    reports:
      junit: apps/backend/test-results/e2e-results.xml
    paths:
      - apps/backend/test-results/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:accessibility:
  stage: test
  image: node:${NODE_VERSION}-alpine
  needs: ['validate:dependencies']
  script:
    - echo "‚ôø Running accessibility tests"
    - cd apps/web
    - npm run test:accessibility
  artifacts:
    expire_in: 1 week
    reports:
      junit: apps/web/test-results/accessibility-results.xml
    paths:
      - apps/web/test-results/accessibility/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# BUILD STAGE
# ================================

build:docker:frontend:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  needs: ['test:unit:frontend', 'test:integration:frontend']
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "üê≥ Building frontend Docker image"
    - docker build -f apps/web/Dockerfile -t $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/frontend:latest
        docker push $CI_REGISTRY_IMAGE/frontend:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

build:docker:backend:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  needs: ['test:unit:backend', 'test:integration:backend']
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "üê≥ Building backend Docker image"
    - docker build -f apps/backend/Dockerfile -t $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/backend:latest
        docker push $CI_REGISTRY_IMAGE/backend:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ================================
# SECURITY STAGE
# ================================

include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml

sast:
  stage: security
  needs: []
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

secret_detection:
  stage: security
  needs: []
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

dependency_scanning:
  stage: security
  needs: []
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

container_scanning:frontend:
  extends: container_scanning
  stage: security
  needs: ['build:docker:frontend']
  variables:
    CI_APPLICATION_REPOSITORY: $CI_REGISTRY_IMAGE/frontend
    CI_APPLICATION_TAG: $CI_COMMIT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

container_scanning:backend:
  extends: container_scanning
  stage: security
  needs: ['build:docker:backend']
  variables:
    CI_APPLICATION_REPOSITORY: $CI_REGISTRY_IMAGE/backend
    CI_APPLICATION_TAG: $CI_COMMIT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ================================
# QUALITY STAGE
# ================================

quality:coverage-check:
  stage: quality
  image: node:${NODE_VERSION}-alpine
  needs: ['test:unit:frontend', 'test:unit:backend']
  script:
    - echo "üìä Checking coverage thresholds"
    - |
      FRONTEND_COVERAGE=$(grep -o 'lines.*%' apps/web/coverage/lcov-report/index.html | grep -o '[0-9]*\.[0-9]*' | head -1)
      BACKEND_COVERAGE=$(grep -o 'lines.*%' apps/backend/coverage/lcov-report/index.html | grep -o '[0-9]*\.[0-9]*' | head -1)

      echo "Frontend Coverage: ${FRONTEND_COVERAGE}%"
      echo "Backend Coverage: ${BACKEND_COVERAGE}%"

      if (( $(echo "${FRONTEND_COVERAGE} < ${COVERAGE_THRESHOLD}" | bc -l) )); then
        echo "‚ùå Frontend coverage ${FRONTEND_COVERAGE}% is below threshold ${COVERAGE_THRESHOLD}%"
        exit 1
      fi

      if (( $(echo "${BACKEND_COVERAGE} < ${COVERAGE_THRESHOLD}" | bc -l) )); then
        echo "‚ùå Backend coverage ${BACKEND_COVERAGE}% is below threshold ${COVERAGE_THRESHOLD}%"
        exit 1
      fi

      echo "‚úÖ All coverage thresholds met"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# STAGING DEPLOYMENT
# ================================

deploy:staging:
  stage: deploy-staging
  image: docker:24-dind
  services:
    - docker:24-dind
  needs:
    - 'build:docker:frontend'
    - 'build:docker:backend'
    - 'quality:coverage-check'
  environment:
    name: staging
    url: $STAGING_URL
  before_script:
    - apk add --no-cache curl docker-compose
  script:
    - echo "üöÄ Deploying to staging environment"
    - |
      # Create staging docker-compose
      cat > docker-compose.staging.yml << EOF
      version: '3.8'
      services:
        postgres:
          image: postgres:15
          environment:
            POSTGRES_DB: moneywise_staging
            POSTGRES_USER: postgres
            POSTGRES_PASSWORD: \$POSTGRES_PASSWORD
          ports:
            - "5433:5432"
          volumes:
            - postgres_staging_data:/var/lib/postgresql/data

        redis:
          image: redis:7-alpine
          ports:
            - "6380:6379"
          volumes:
            - redis_staging_data:/data

        backend:
          image: \$CI_REGISTRY_IMAGE/backend:\$CI_COMMIT_SHA
          ports:
            - "3003:3002"
          environment:
            - NODE_ENV=staging
            - DB_HOST=postgres
            - DB_PORT=5432
            - DB_USERNAME=postgres
            - DB_PASSWORD=\$POSTGRES_PASSWORD
            - DB_NAME=moneywise_staging
            - REDIS_HOST=redis
            - REDIS_PORT=6379
            - JWT_SECRET=\$JWT_SECRET_STAGING
          depends_on:
            - postgres
            - redis

        frontend:
          image: \$CI_REGISTRY_IMAGE/frontend:\$CI_COMMIT_SHA
          ports:
            - "3001:3000"
          environment:
            - NODE_ENV=staging
            - NEXT_PUBLIC_API_URL=http://backend:3002
          depends_on:
            - backend

      volumes:
        postgres_staging_data:
        redis_staging_data:
      EOF
    - docker-compose -f docker-compose.staging.yml up -d
    - sleep 30 # Wait for services to start
    - curl -f $STAGING_URL/health || exit 1
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# E2E TESTS
# ================================

test:e2e:staging:
  stage: e2e-tests
  image: mcr.microsoft.com/playwright:v1.40.0-focal
  needs: ['deploy:staging']
  variables:
    PLAYWRIGHT_BASE_URL: $STAGING_URL
  script:
    - echo "üé≠ Running E2E tests against staging"
    - cd apps/web
    - npm ci
    - npx playwright install
    - npx playwright test --config=playwright.config.staging.ts
  artifacts:
    expire_in: 1 week
    paths:
      - apps/web/playwright-report/
      - apps/web/test-results/
    reports:
      junit: apps/web/test-results/results.xml
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:performance:staging:
  stage: e2e-tests
  image: sitespeedio/sitespeed.io:latest
  needs: ['deploy:staging']
  script:
    - echo "‚ö° Running performance tests"
    - sitespeed.io --budget budget.json $STAGING_URL
  artifacts:
    expire_in: 1 week
    paths:
      - sitespeed-result/
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# PRODUCTION DEPLOYMENT
# ================================

deploy:production:
  stage: deploy-production
  image: docker:24-dind
  services:
    - docker:24-dind
  needs:
    - 'test:e2e:staging'
    - 'test:performance:staging'
  environment:
    name: production
    url: $PRODUCTION_URL
  when: manual
  before_script:
    - apk add --no-cache curl docker-compose
  script:
    - echo "üöÄ Deploying to production environment"
    - echo "Creating blue-green deployment strategy"
    - |
      # Blue-Green Deployment Logic
      if docker ps | grep -q "moneywise_blue"; then
        export NEW_COLOR="green"
        export OLD_COLOR="blue"
      else
        export NEW_COLOR="blue"
        export OLD_COLOR="green"
      fi

      echo "Deploying to $NEW_COLOR environment"

      # Deploy new version
      docker-compose -f docker-compose.prod-${NEW_COLOR}.yml up -d

      # Health check
      sleep 60
      if curl -f $PRODUCTION_URL/health; then
        echo "‚úÖ Health check passed, switching traffic"
        # Switch traffic (update load balancer configuration)
        # Stop old version
        docker-compose -f docker-compose.prod-${OLD_COLOR}.yml down
        echo "‚úÖ Production deployment complete"
      else
        echo "‚ùå Health check failed, rolling back"
        docker-compose -f docker-compose.prod-${NEW_COLOR}.yml down
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ================================
# MONITORING STAGE
# ================================

monitor:production:
  stage: monitor
  image: curlimages/curl:latest
  needs: ['deploy:production']
  script:
    - echo "üìä Setting up production monitoring"
    - |
      # Send deployment notification
      curl -X POST $SLACK_WEBHOOK_URL \
        -H 'Content-type: application/json' \
        --data '{"text":"üöÄ MoneyWise '$CI_COMMIT_SHA' deployed to production successfully!"}'

      # Trigger monitoring checks
      curl -X POST $MONITORING_WEBHOOK_URL \
        -H 'Content-type: application/json' \
        --data '{"version":"'$CI_COMMIT_SHA'","environment":"production","timestamp":"'$(date -Iseconds)'"}'
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

# ================================
# ROLLBACK JOB (Manual)
# ================================

rollback:production:
  stage: deploy-production
  image: docker:24-dind
  services:
    - docker:24-dind
  environment:
    name: production
    url: $PRODUCTION_URL
  when: manual
  script:
    - echo "üîÑ Rolling back production deployment"
    - |
      # Get previous successful commit
      PREVIOUS_SHA=$(git log --format="%H" -n 2 | tail -1)
      echo "Rolling back to: $PREVIOUS_SHA"

      # Deploy previous version
      docker pull $CI_REGISTRY_IMAGE/frontend:$PREVIOUS_SHA
      docker pull $CI_REGISTRY_IMAGE/backend:$PREVIOUS_SHA

      # Update deployment with previous version
      # (Implementation depends on your deployment strategy)

      echo "‚úÖ Rollback completed"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
